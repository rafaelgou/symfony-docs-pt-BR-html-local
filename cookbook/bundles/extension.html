<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Como expor uma Configuração Semântica para um Bundle &mdash; Symfony2.4Docs 2.4 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Symfony2.4Docs 2.4 documentation" href="../../index.html" />
    <link rel="up" title="Bundles" href="index.html" />
    <link rel="next" title="Email" href="../email/index.html" />
    <link rel="prev" title="Como Sobrescrever qualquer parte de um Bundle" href="override.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../email/index.html" title="Email"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="override.html" title="Como Sobrescrever qualquer parte de um Bundle"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">Symfony2.4Docs 2.4 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Cookbook</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Bundles</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="como-expor-uma-configuracao-semantica-para-um-bundle">
<span id="index-0"></span><h1>Como expor uma Configuração Semântica para um Bundle<a class="headerlink" href="#como-expor-uma-configuracao-semantica-para-um-bundle" title="Permalink to this headline">¶</a></h1>
<p>Se você abrir o arquivo de configuração da sua aplicação (geralmente <tt class="docutils literal"><span class="pre">app/config/config.yml</span></tt>),
verá um número de diferentes &#8220;namespaces&#8221; de configurações, como <tt class="docutils literal"><span class="pre">framework</span></tt>,
<tt class="docutils literal"><span class="pre">twig</span></tt> e <tt class="docutils literal"><span class="pre">doctrine</span></tt>. Cada um deles configura um bundle específico, permitindo configurar
as coisas a um alto nível e deixar o bundle fazer todas as modificações complexas,
de baixo nível resultantes.</p>
<p>Por exemplo, o código a seguir diz ao <tt class="docutils literal"><span class="pre">FrameworkBundle</span></tt> para habilitar a integração do
formulário, a qual envolve a definição de alguns serviços, bem
como a integração de outros componentes relacionados:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="l-Scalar-Plain">framework</span><span class="p-Indicator">:</span>
    <span class="c1"># ...</span>
    <span class="l-Scalar-Plain">form</span><span class="p-Indicator">:</span>            <span class="l-Scalar-Plain">true</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="nt">&lt;framework:config&gt;</span>
    <span class="nt">&lt;framework:form</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/framework:config&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="nv">$container</span><span class="o">-&gt;</span><span class="na">loadFromExtension</span><span class="p">(</span><span class="s1">&#39;framework&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="c1">// ...</span>
    <span class="s1">&#39;form&#39;</span>            <span class="o">=&gt;</span> <span class="k">true</span><span class="p">,</span>
    <span class="c1">// ...</span>
<span class="p">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Quando você cria um bundle, você tem duas opções para lidar com a configuração:</p>
<ol class="arabic">
<li><p class="first"><strong>Configuração de Serviço Normal</strong> (<em>fácil</em>):</p>
<blockquote>
<div><p>Você pode especificar seus serviços em um arquivo de configuração (por exemplo <tt class="docutils literal"><span class="pre">services.yml</span></tt>)
que reside em seu bundle e, então, importá-lo a partir da configuração principal da
sua aplicação. Isto é realmente fácil, rápido e totalmente eficaz. Se você
fazer uso de <a class="reference internal" href="../../book/service_container.html#book-service-container-parameters"><em>parâmetros</em></a>, então,
você ainda tem a flexibilidade para personalizar seu bundle a partir da configuração
da sua aplicação. Veja &#8220;<a class="reference internal" href="../../book/service_container.html#service-container-imports-directive"><em>Importando configuração com imports</em></a>&#8221; para mais
detalhes.</p>
</div></blockquote>
</li>
<li><p class="first"><strong>Expondo Configuração Semântica</strong> (<em>avançado</em>):</p>
<blockquote>
<div><p>Esta é a maneira como a configuração é feita com os bundles do núcleo (como descrito
acima). A idéia básica é que, em vez de o usuário sobrescrever parâmetros
individuais, você deixa ele configurar apenas algumas opções criadas
. Como desenvolvedor do bundle, você então faz o parse desta configuração
e carrega os serviços dentro de uma classe &#8220;Extension&#8221;. Com este método, você não vai
precisar importar quaisquer recursos de configuração a partir da configuração principal da
sua aplicação: a classe de Extensão (Extension) pode lidar com tudo isso.</p>
</div></blockquote>
</li>
</ol>
<p>A segunda opção - que você vai aprender neste artigo - é muito mais flexível, mas
também requer mais tempo para configurar. Se você está se perguntando qual
método deve usar, provavelmente é uma boa idéia começar com o método 1,
e depois mudar para o 2 mais tarde, se você precisar.</p>
<p>O segundo método tem várias vantagens específicas:</p>
<ul class="simple">
<li>Muito mais poderoso do que simplesmente definir parâmetros: um valor de opção específico
pode acionar a criação de muitas definições de serviço;</li>
<li>Possibilidade de ter hierarquia de configuração</li>
<li>Smart merging quando possuir vários arquivos de configuração (por exemplo <tt class="docutils literal"><span class="pre">config_dev.yml</span></tt>
e <tt class="docutils literal"><span class="pre">config.yml</span></tt>) sobrescrevendo a configuração um do outro;</li>
<li>Validação de configuração (se você usar uma <a class="reference internal" href="#cookbook-bundles-extension-config-class"><em>Classe de Configuração</em></a>);</li>
<li>Auto-completar da IDE quando você criar um XSD e os desenvolvedores usarem XML.</li>
</ul>
<div class="sidebar">
<p class="first sidebar-title">Sobresecrevendo parâmetros do bundle</p>
<p class="last">Se um Bundle fornecer uma classe Extension, então, você geralmente <em>não</em> deve
sobrescrever quaisquer parâmetros do container de serviço daquele bundle. A idéia
é que, se uma classe Extension estiver presente, cada definição que deve ser
configurável deve estar presente na configuração disponibilizada por
esta classe. Em outras palavras, a classe Extension as definições de configuração
públicas suportadas para as quais a compatibilidade com versões anteriores
será mantida.</p>
</div>
<div class="section" id="criando-uma-classe-extension">
<span id="index-1"></span><h2>Criando uma Classe Extension<a class="headerlink" href="#criando-uma-classe-extension" title="Permalink to this headline">¶</a></h2>
<p>Se você optar por expor uma configuração semântica para seu bundle, você vai
precisar primeiro criar uma nova classe &#8220;Extension&#8221;, que irá lidar com o processo.
Esta classe deve residir no diretório <tt class="docutils literal"><span class="pre">DependencyInjection</span></tt> de seu bundle
e o seu nome deve ser construído substituindo o sufixo <tt class="docutils literal"><span class="pre">Bundle</span></tt> do
nome da classe Bundle por <tt class="docutils literal"><span class="pre">Extension</span></tt>. Por exemplo, a classe Extension
do <tt class="docutils literal"><span class="pre">AcmeHelloBundle</span></tt> seria chamada <tt class="docutils literal"><span class="pre">AcmeHelloExtension</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>// Acme/HelloBundle/DependencyInjection/AcmeHelloExtension.php
namespace Acme\HelloBundle\DependencyInjection;

use Symfony\Component\HttpKernel\DependencyInjection\Extension;
use Symfony\Component\DependencyInjection\ContainerBuilder;

class AcmeHelloExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        // ... where all of the heavy logic is done
    }

    public function getXsdValidationBasePath()
    {
        return __DIR__.&#39;/../Resources/config/&#39;;
    }

    public function getNamespace()
    {
        return &#39;http://www.example.com/symfony/schema/&#39;;
    }
}
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Os métodos <tt class="docutils literal"><span class="pre">getXsdValidationBasePath</span></tt> e <tt class="docutils literal"><span class="pre">getNamespace</span></tt> são necessários apenas
se o bundle fornece XSDs opcionais para a configuração.</p>
</div>
<p>A presença da classe anterior significa que agora você pode definir um namespace de configuração
<tt class="docutils literal"><span class="pre">acme_hello</span></tt> em qualquer arquivo de configuração. O namespace <tt class="docutils literal"><span class="pre">acme_hello</span></tt>
é construído a partir do nome da classe de extensão, removendo a palavra <tt class="docutils literal"><span class="pre">Extension</span></tt>
e, em seguida, deixando o resto do nome todo em letras minúsculas e com underscores. Em outras
palavras, <tt class="docutils literal"><span class="pre">AcmeHelloExtension</span></tt> torna-se <tt class="docutils literal"><span class="pre">acme_hello</span></tt>.</p>
<p>Você pode começar a especificar a configuração sob este namespace imediatamente:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># app/config/config.yml</span>
<span class="l-Scalar-Plain">acme_hello</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">~</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="c">&lt;!-- app/config/config.xml --&gt;</span>
<span class="cp">&lt;?xml version=&quot;1.0&quot; ?&gt;</span>

<span class="nt">&lt;container</span> <span class="na">xmlns=</span><span class="s">&quot;http://symfony.com/schema/dic/services&quot;</span>
    <span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="na">xmlns:acme_hello=</span><span class="s">&quot;http://www.example.com/symfony/schema/&quot;</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://www.example.com/symfony/schema/ http://www.example.com/symfony/schema/hello-1.0.xsd&quot;</span><span class="nt">&gt;</span>

   <span class="nt">&lt;acme_hello:config</span> <span class="nt">/&gt;</span>

   <span class="c">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;/container&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="c1">// app/config/config.php</span>
<span class="nv">$container</span><span class="o">-&gt;</span><span class="na">loadFromExtension</span><span class="p">(</span><span class="s1">&#39;acme_hello&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">());</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Se você seguir as convenções de nomenclatura estabelecidas acima, então, o método
<tt class="docutils literal"><span class="pre">load()</span></tt> de seu código de extensão é sempre chamado, uma vez que seu bundle
está registrado no Kernel. Em outras palavras, mesmo se o usuário não
fornecer qualquer configuração (ou seja, a entrada <tt class="docutils literal"><span class="pre">acme_hello</span></tt> nem mesmo
aparecer), o método <tt class="docutils literal"><span class="pre">load()</span></tt> será chamado e passado um array <tt class="docutils literal"><span class="pre">$configs</span></tt>
vazio. Você ainda pode fornecer alguns padrões ​​para seu bundle se
desejar.</p>
</div>
</div>
<div class="section" id="fazendo-o-parse-do-array-configs">
<h2>Fazendo o parse do array <tt class="docutils literal"><span class="pre">$configs</span></tt><a class="headerlink" href="#fazendo-o-parse-do-array-configs" title="Permalink to this headline">¶</a></h2>
<p>Sempre que um usuário inclui o namespace <tt class="docutils literal"><span class="pre">acme_hello</span></tt> em um arquivo de configuração,
a configuração abaixo dele é adicionada à um array de configurações e
passado para o método <tt class="docutils literal"><span class="pre">load()</span></tt> de sua extensão (o Symfony2 automaticamente
converte XML e YAML para um array).</p>
<p>Assuma a seguinte configuração:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># app/config/config.yml</span>
<span class="l-Scalar-Plain">acme_hello</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">foo</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">fooValue</span>
    <span class="l-Scalar-Plain">bar</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">barValue</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="c">&lt;!-- app/config/config.xml --&gt;</span>
<span class="cp">&lt;?xml version=&quot;1.0&quot; ?&gt;</span>

<span class="nt">&lt;container</span> <span class="na">xmlns=</span><span class="s">&quot;http://symfony.com/schema/dic/services&quot;</span>
    <span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="na">xmlns:acme_hello=</span><span class="s">&quot;http://www.example.com/symfony/schema/&quot;</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://www.example.com/symfony/schema/ http://www.example.com/symfony/schema/hello-1.0.xsd&quot;</span><span class="nt">&gt;</span>

    <span class="nt">&lt;acme_hello:config</span> <span class="na">foo=</span><span class="s">&quot;fooValue&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;acme_hello:bar&gt;</span>barValue<span class="nt">&lt;/acme_hello:bar&gt;</span>
    <span class="nt">&lt;/acme_hello:config&gt;</span>

<span class="nt">&lt;/container&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="c1">// app/config/config.php</span>
<span class="nv">$container</span><span class="o">-&gt;</span><span class="na">loadFromExtension</span><span class="p">(</span><span class="s1">&#39;acme_hello&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;foo&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;fooValue&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bar&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;barValue&#39;</span><span class="p">,</span>
<span class="p">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>O array passado para seu método <tt class="docutils literal"><span class="pre">load()</span></tt> ficará parecido com o seguinte:</p>
<div class="highlight-python"><div class="highlight"><pre>array(
    array(
        &#39;foo&#39; =&gt; &#39;fooValue&#39;,
        &#39;bar&#39; =&gt; &#39;barValue&#39;,
    )
)
</pre></div>
</div>
<p>Observe que este é um <em>array de arrays</em>, e não apenas um único array simples de
valores de configuração. Isso é intencional. Por exemplo, se <tt class="docutils literal"><span class="pre">acme_hello</span></tt> aparece em
outro arquivo de configuração - digamos <tt class="docutils literal"><span class="pre">config_dev.yml</span></tt> - com valores diferentes
abaixo dele, então, o array de entrada poderia ser assim:</p>
<div class="highlight-python"><div class="highlight"><pre>array(
    array(
        &#39;foo&#39; =&gt; &#39;fooValue&#39;,
        &#39;bar&#39; =&gt; &#39;barValue&#39;,
    ),
    array(
        &#39;foo&#39; =&gt; &#39;fooDevValue&#39;,
        &#39;baz&#39; =&gt; &#39;newConfigEntry&#39;,
    ),
)
</pre></div>
</div>
<p>A ordem dos dois arrays depende de qual é definido primeiro.</p>
<p>É o seu trabalho, então, decidir como deve ser o merge dessas configurações
. Você pode, por exemplo, ter valores posteriores sobrescrevendo os valores anteriores
ou de alguma forma fazer o merge deles.</p>
<p>Mais tarde, na seção sobre a <a class="reference internal" href="#cookbook-bundles-extension-config-class"><em>Classe de Configuração</em></a>
, você vai aprender uma forma verdadeiramente robusta para lidar com isso. Mas, por ora,
você pode apenas fazer o merge manualmente:</p>
<div class="highlight-python"><div class="highlight"><pre>public function load(array $configs, ContainerBuilder $container)
{
    $config = array();
    foreach ($configs as $subConfig) {
        $config = array_merge($config, $subConfig);
    }

    // ... now use the flat $config array
}
</pre></div>
</div>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">Certifique-se que a técnica de merge acima faz sentido para o seu bundle. Este
é apenas um exemplo, e você deve ter cuidado para não usá-lo cegamente.</p>
</div>
</div>
<div class="section" id="usando-o-metodo-load">
<h2>Usando o Método <tt class="docutils literal"><span class="pre">load()</span></tt><a class="headerlink" href="#usando-o-metodo-load" title="Permalink to this headline">¶</a></h2>
<p>Dentro do <tt class="docutils literal"><span class="pre">load()</span></tt> a variável <tt class="docutils literal"><span class="pre">$container</span></tt> refere-se a um container que apenas
sabe sobre essa configuração de namespace (ou seja, não contêm informação de serviço
carregada a partir de outros bundles). O objetivo do método <tt class="docutils literal"><span class="pre">load()</span></tt>
é manipular o container, adicionando e configurando quaisquer métodos ou serviços
necessários ao seu bundle.</p>
<div class="section" id="carregando-recursos-de-configuracao-externos">
<h3>Carregando Recursos de Configuração Externos<a class="headerlink" href="#carregando-recursos-de-configuracao-externos" title="Permalink to this headline">¶</a></h3>
<p>Algo comum de se fazer é carregar um arquivo de configuração externo que pode conter a
maioria dos serviços necessários para o seu bundle. Por exemplo, suponha que você tem
um arquivo <tt class="docutils literal"><span class="pre">services.xml</span></tt> que contém muitas das configurações de serviços do seu
bundle:</p>
<div class="highlight-python"><div class="highlight"><pre>use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;
use Symfony\Component\Config\FileLocator;

public function load(array $configs, ContainerBuilder $container)
{
    // ... prepare your $config variable

    $loader = new XmlFileLoader($container, new FileLocator(__DIR__.&#39;/../Resources/config&#39;));
    $loader-&gt;load(&#39;services.xml&#39;);
}
</pre></div>
</div>
<p>Você pode até fazer isso condicionalmente, com base em um dos valores de configuração.
Por exemplo, supondo que você quer carregar um conjunto de serviços somente se a opção
<tt class="docutils literal"><span class="pre">enabled</span></tt> for passada e definida com true:</p>
<div class="highlight-python"><div class="highlight"><pre>public function load(array $configs, ContainerBuilder $container)
{
    // ... prepare your $config variable

    $loader = new XmlFileLoader($container, new FileLocator(__DIR__.&#39;/../Resources/config&#39;));

    if (isset($config[&#39;enabled&#39;]) &amp;&amp; $config[&#39;enabled&#39;]) {
        $loader-&gt;load(&#39;services.xml&#39;);
    }
}
</pre></div>
</div>
</div>
<div class="section" id="configurando-servicos-e-definindo-parametros">
<h3>Configurando Serviços e Definindo Parâmetros<a class="headerlink" href="#configurando-servicos-e-definindo-parametros" title="Permalink to this headline">¶</a></h3>
<p>Uma vez que você já carregou alguma configuração de serviço, você pode precisar modificar a
configuração com base em alguns dos valores de entrada. Por exemplo, supondo que existe um
serviço cujo primeiro argumento é alguma string &#8220;type&#8221; que ele irá usar internamente.
Você gostaria que isto fosse facilmente configurado pelo usuário do bundle,
então, em seu arquivo de configuração do serviço (ex. <tt class="docutils literal"><span class="pre">services.xml</span></tt>), você define este
serviço e usa um parâmetro em branco - <tt class="docutils literal"><span class="pre">acme_hello.my_service_type</span></tt> - como
seu primeiro argumento:</p>
<div class="highlight-xml"><div class="highlight"><pre><span class="c">&lt;!-- src/Acme/HelloBundle/Resources/config/services.xml --&gt;</span>
<span class="nt">&lt;container</span> <span class="na">xmlns=</span><span class="s">&quot;http://symfony.com/schema/dic/services&quot;</span>
    <span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd&quot;</span><span class="nt">&gt;</span>

    <span class="nt">&lt;parameters&gt;</span>
        <span class="nt">&lt;parameter</span> <span class="na">key=</span><span class="s">&quot;acme_hello.my_service_type&quot;</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/parameters&gt;</span>

    <span class="nt">&lt;services&gt;</span>
        <span class="nt">&lt;service</span> <span class="na">id=</span><span class="s">&quot;acme_hello.my_service&quot;</span> <span class="na">class=</span><span class="s">&quot;Acme\HelloBundle\MyService&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;argument&gt;</span>%acme_hello.my_service_type%<span class="nt">&lt;/argument&gt;</span>
        <span class="nt">&lt;/service&gt;</span>
    <span class="nt">&lt;/services&gt;</span>
<span class="nt">&lt;/container&gt;</span>
</pre></div>
</div>
<p>Mas por que definir um parâmetro vazio e então passá-lo ao seu serviço?
A resposta é que você vai definir este parâmetro em sua classe de extensão, com base
nos valores de configuração de entrada. Suponha, por exemplo, que você quer
permitir ao usuário definir esta opção <em>type</em> sob uma chave chamada <tt class="docutils literal"><span class="pre">my_type</span></tt>.
Para fazer isso, adicione o seguinte ao método <tt class="docutils literal"><span class="pre">load()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>public function load(array $configs, ContainerBuilder $container)
{
    // ... prepare your $config variable

    $loader = new XmlFileLoader($container, new FileLocator(__DIR__.&#39;/../Resources/config&#39;));
    $loader-&gt;load(&#39;services.xml&#39;);

    if (!isset($config[&#39;my_type&#39;])) {
        throw new \InvalidArgumentException(&#39;The &quot;my_type&quot; option must be set&#39;);
    }

    $container-&gt;setParameter(&#39;acme_hello.my_service_type&#39;, $config[&#39;my_type&#39;]);
}
</pre></div>
</div>
<p>Agora, o usuário pode efetivamente configurar o serviço especificando o valor
de configuração <tt class="docutils literal"><span class="pre">my_type</span></tt>:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># app/config/config.yml</span>
<span class="l-Scalar-Plain">acme_hello</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">my_type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">foo</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="c">&lt;!-- app/config/config.xml --&gt;</span>
<span class="cp">&lt;?xml version=&quot;1.0&quot; ?&gt;</span>

<span class="nt">&lt;container</span> <span class="na">xmlns=</span><span class="s">&quot;http://symfony.com/schema/dic/services&quot;</span>
    <span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="na">xmlns:acme_hello=</span><span class="s">&quot;http://www.example.com/symfony/schema/&quot;</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://www.example.com/symfony/schema/ http://www.example.com/symfony/schema/hello-1.0.xsd&quot;</span><span class="nt">&gt;</span>

    <span class="nt">&lt;acme_hello:config</span> <span class="na">my_type=</span><span class="s">&quot;foo&quot;</span><span class="nt">&gt;</span>
        <span class="c">&lt;!-- ... --&gt;</span>
    <span class="nt">&lt;/acme_hello:config&gt;</span>

<span class="nt">&lt;/container&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="c1">// app/config/config.php</span>
<span class="nv">$container</span><span class="o">-&gt;</span><span class="na">loadFromExtension</span><span class="p">(</span><span class="s1">&#39;acme_hello&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;my_type&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
    <span class="c1">// ...</span>
<span class="p">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="parametros-globais">
<h3>Parâmetros Globais<a class="headerlink" href="#parametros-globais" title="Permalink to this headline">¶</a></h3>
<p>Quando estiver configurando o container, esteja ciente de que você tem os seguintes
parâmetros globais disponíveis para uso:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">kernel.name</span></tt></li>
<li><tt class="docutils literal"><span class="pre">kernel.environment</span></tt></li>
<li><tt class="docutils literal"><span class="pre">kernel.debug</span></tt></li>
<li><tt class="docutils literal"><span class="pre">kernel.root_dir</span></tt></li>
<li><tt class="docutils literal"><span class="pre">kernel.cache_dir</span></tt></li>
<li><tt class="docutils literal"><span class="pre">kernel.logs_dir</span></tt></li>
<li><tt class="docutils literal"><span class="pre">kernel.bundle_dirs</span></tt></li>
<li><tt class="docutils literal"><span class="pre">kernel.bundles</span></tt></li>
<li><tt class="docutils literal"><span class="pre">kernel.charset</span></tt></li>
</ul>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">Todos os nomes de parâmetros e serviços, começando com um <tt class="docutils literal"><span class="pre">_</span></tt> são reservados para o
framework, e os novos não devem ser definidos por bundles.</p>
</div>
</div>
</div>
<div class="section" id="validacao-e-merging-com-uma-classe-de-configuracao">
<span id="cookbook-bundles-extension-config-class"></span><h2>Validação e Merging com uma Classe de Configuração<a class="headerlink" href="#validacao-e-merging-com-uma-classe-de-configuracao" title="Permalink to this headline">¶</a></h2>
<p>Até agora, você já fez o merge de seus arrays de configuração manualmente e
está verificando a presença de valores de configuração manualmente usando a função <tt class="docutils literal"><span class="pre">isset()</span></tt>
do PHP. Um sistema opcional de <em>Configuração</em> está também disponível que
pode ajudar com merge, validação, valores padrão e normalização de formato.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Normalização de formato refere-se ao fato de que certos formatos - em grande parte XML -
resultam em arrays de configuração ligeiramente diferentes e que estes arrays
precisam ser &#8220;normalizados&#8221; para corresponder com todo o resto.</p>
</div>
<p>Para tirar vantagem deste sistema, você vai criar uma classe <tt class="docutils literal"><span class="pre">Configuration</span></tt>
e construir uma árvore que define a sua configuração nesta classe:</p>
<div class="highlight-python"><div class="highlight"><pre>// src/Acme/HelloBundle/DependencyInjection/Configuration.php
namespace Acme\HelloBundle\DependencyInjection;

use Symfony\Component\Config\Definition\Builder\TreeBuilder;
use Symfony\Component\Config\Definition\ConfigurationInterface;

class Configuration implements ConfigurationInterface
{
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder();
        $rootNode = $treeBuilder-&gt;root(&#39;acme_hello&#39;);

        $rootNode
            -&gt;children()
            -&gt;scalarNode(&#39;my_type&#39;)-&gt;defaultValue(&#39;bar&#39;)-&gt;end()
            -&gt;end();

        return $treeBuilder;
    }
</pre></div>
</div>
<p>Este é um exemplo <em>muito</em> simples, mas agora você pode usar essa classe em seu método
<tt class="docutils literal"><span class="pre">load()</span></tt> para o merge da sua configuração e forçar a validação. Se outras opções
que não sejam <tt class="docutils literal"><span class="pre">my_type</span></tt> forem passadas, o usuário será notificado com uma exceção
de que uma opção não suportada foi passada:</p>
<div class="highlight-python"><div class="highlight"><pre>public function load(array $configs, ContainerBuilder $container)
{
    $configuration = new Configuration();

    $config = $this-&gt;processConfiguration($configuration, $configs);

    // ...
}
</pre></div>
</div>
<p>O método <tt class="docutils literal"><span class="pre">processConfiguration()</span></tt> usa a árvore de configuração que você definiu
na classe <tt class="docutils literal"><span class="pre">Configuration</span></tt> para validar, normalizar e fazer o merge de todos os
arrays de configuração em conjunto.</p>
<p>A classe <a href="#id1"><span class="problematic" id="id2">``</span></a>Configuration` pode ser muito mais complicada do que mostramos aqui,
suportando array nodes, &#8220;prototype&#8221; nodes, validação avançada, normalização específica de XML
e merge avançado. Você pode ler mais sobre isso na <a class="reference internal" href="../../components/config/definition.html"><em>documentação do Componente de Configuração</em></a>.
Você também pode vê-lo em ação verificando algumas das classes de Configuração do núcleo,
tais como a <a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Bundle/FrameworkBundle/DependencyInjection/Configuration.php">Configuração do FrameworkBundle</a> ou a <a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Bundle/TwigBundle/DependencyInjection/Configuration.php">Configuração do TwigBundle</a>.</p>
<div class="section" id="dump-de-configuracao-padrao">
<h3>Dump de Configuração Padrão<a class="headerlink" href="#dump-de-configuracao-padrao" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.1: </span>O comando <tt class="docutils literal"><span class="pre">config:dump-reference</span></tt> foi adicionado no Symfony 2.1</p>
</div>
<p>O comando <tt class="docutils literal"><span class="pre">config:dump-reference</span></tt> permite que a configuração padrão de um bundle
seja impressa no console em YAML.</p>
<p>Enquanto a configuração do bundle está localizada no local padrão
(<tt class="docutils literal"><span class="pre">YourBundle\DependencyInjection\Configuration</span></tt>) e não tem um
<tt class="docutils literal"><span class="pre">__constructor()</span></tt> ele vai funcionar automaticamente.  Se você tem algo
diferente a sua classe <tt class="docutils literal"><span class="pre">Extension</span></tt> terá que sobrescrever o
método <tt class="docutils literal"><span class="pre">Extension::getConfiguration()</span></tt>.  Fazendo ele retornar uma instância de sua
<tt class="docutils literal"><span class="pre">Configuration</span></tt>.</p>
<p>Comentários e exemplos podem ser adicionados aos nós de configuração utilizando os
métodos <tt class="docutils literal"><span class="pre">-&gt;info()</span></tt> e <tt class="docutils literal"><span class="pre">-&gt;example()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>// src/Acme/HelloBundle/DependencyExtension/Configuration.php
namespace Acme\HelloBundle\DependencyInjection;

use Symfony\Component\Config\Definition\Builder\TreeBuilder;
use Symfony\Component\Config\Definition\ConfigurationInterface;

class Configuration implements ConfigurationInterface
{
    public function getConfigTreeBuilder()
    {
        $treeBuilder = new TreeBuilder();
        $rootNode = $treeBuilder-&gt;root(&#39;acme_hello&#39;);

        $rootNode
            -&gt;children()
                -&gt;scalarNode(&#39;my_type&#39;)
                    -&gt;defaultValue(&#39;bar&#39;)
                    -&gt;info(&#39;what my_type configures&#39;)
                    -&gt;example(&#39;example setting&#39;)
                -&gt;end()
            -&gt;end()
        ;

        return $treeBuilder;
    }
</pre></div>
</div>
<p>Este texto aparece como comentários yaml na saída do comando
<tt class="docutils literal"><span class="pre">config:dump-reference</span></tt>.</p>
</div>
</div>
<div class="section" id="convencoes-de-extensao">
<span id="index-2"></span><h2>Convenções de Extensão<a class="headerlink" href="#convencoes-de-extensao" title="Permalink to this headline">¶</a></h2>
<p>Ao criar uma extensão, siga estas convenções simples:</p>
<ul class="simple">
<li>A extensão deve ser armazenada no sub-namespace <tt class="docutils literal"><span class="pre">DependencyInjection</span></tt>;</li>
<li>A extensão deve ser nomeada após o nome do bundle e com o sufixo
<tt class="docutils literal"><span class="pre">Extension</span></tt> (<tt class="docutils literal"><span class="pre">AcmeHelloExtension</span></tt> para <tt class="docutils literal"><span class="pre">AcmeHelloBundle</span></tt>);</li>
<li>A extensão deve fornecer um esquema XSD.</li>
</ul>
<p>Se você seguir estas convenções simples, suas extensões serão registradas
automaticamente pelo Symfony2. Se não, sobrescreva o método Bundle
<tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/Bundle/Bundle.html#method_build" title="Symfony\Component\HttpKernel\Bundle\Bundle::build()"><span class="pre">build()</span></a></tt> em
seu bundle:</p>
<div class="highlight-python"><div class="highlight"><pre>// ...
use Acme\HelloBundle\DependencyInjection\UnconventionalExtensionClass;

class AcmeHelloBundle extends Bundle
{
    public function build(ContainerBuilder $container)
    {
        parent::build($container);

        // register extensions that do not follow the conventions manually
        $container-&gt;registerExtension(new UnconventionalExtensionClass());
    }
}
</pre></div>
</div>
<p>Neste caso, a classe de extensão também deve implementar um método <tt class="docutils literal"><span class="pre">getAlias()</span></tt>
e retornar um alias exclusivo nomeado após o bundle (por exemplo, <tt class="docutils literal"><span class="pre">acme_hello</span></tt>). Isto
é necessário porque o nome da classe não segue os padrões terminando
em <tt class="docutils literal"><span class="pre">Extension</span></tt>.</p>
<p>Além disso, o método <tt class="docutils literal"><span class="pre">load()</span></tt> de sua extensão será <em>apenas</em> chamado
se o usuário especificar o alias <tt class="docutils literal"><span class="pre">acme_hello</span></tt> em pelo menos um arquivo de configuração
. Mais uma vez, isso é porque a classe de extensão não segue os
padrões acima referidos, de modo que, nada acontece automaticamente.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Como expor uma Configuração Semântica para um Bundle</a><ul>
<li><a class="reference internal" href="#criando-uma-classe-extension">Criando uma Classe Extension</a></li>
<li><a class="reference internal" href="#fazendo-o-parse-do-array-configs">Fazendo o parse do array <tt class="docutils literal"><span class="pre">$configs</span></tt></a></li>
<li><a class="reference internal" href="#usando-o-metodo-load">Usando o Método <tt class="docutils literal"><span class="pre">load()</span></tt></a><ul>
<li><a class="reference internal" href="#carregando-recursos-de-configuracao-externos">Carregando Recursos de Configuração Externos</a></li>
<li><a class="reference internal" href="#configurando-servicos-e-definindo-parametros">Configurando Serviços e Definindo Parâmetros</a></li>
<li><a class="reference internal" href="#parametros-globais">Parâmetros Globais</a></li>
</ul>
</li>
<li><a class="reference internal" href="#validacao-e-merging-com-uma-classe-de-configuracao">Validação e Merging com uma Classe de Configuração</a><ul>
<li><a class="reference internal" href="#dump-de-configuracao-padrao">Dump de Configuração Padrão</a></li>
</ul>
</li>
<li><a class="reference internal" href="#convencoes-de-extensao">Convenções de Extensão</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="override.html"
                        title="previous chapter">Como Sobrescrever qualquer parte de um Bundle</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../email/index.html"
                        title="next chapter">Email</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/cookbook/bundles/extension.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../email/index.html" title="Email"
             >next</a> |</li>
        <li class="right" >
          <a href="override.html" title="Como Sobrescrever qualquer parte de um Bundle"
             >previous</a> |</li>
        <li><a href="../../index.html">Symfony2.4Docs 2.4 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Cookbook</a> &raquo;</li>
          <li><a href="index.html" >Bundles</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Symfony Team + Symfony pt_BR Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>