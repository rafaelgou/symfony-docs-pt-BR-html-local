

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Fundamentos de Symfony e HTTP &mdash; Symfony2Docs 2.0.x documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0.x',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Symfony2Docs 2.0.x documentation" href="../index.html" />
    <link rel="up" title="Livro" href="index.html" />
    <link rel="next" title="Symfony2 versus o PHP puro" href="from_flat_php_to_symfony2.html" />
    <link rel="prev" title="Livro" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="from_flat_php_to_symfony2.html" title="Symfony2 versus o PHP puro"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Livro"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Symfony2Docs 2.0.x documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Livro</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="fundamentos-de-symfony-e-http">
<span id="index-0"></span><h1>Fundamentos de Symfony e HTTP<a class="headerlink" href="#fundamentos-de-symfony-e-http" title="Permalink to this headline">¶</a></h1>
<p>Parabéns! Aprendendo sobre o Symfony2, você está no caminho certo para ser um
desenvolvedor web mais <em>produtivo</em>, <em>bem preparado</em> e <em>popular</em> (na verdade,
este último é por sua própria conta). O Symfony2 foi criado para voltar ao básico:
desenvolver ferramentas para ajuda-lo a criar aplicações mais robustas de
uma maneira mais rápida sem ficar no seu caminho. Ele foi construído baseando-se
nas melhores ideias de diversas tecnologias: as ferramentas e conceitos que você
está prestes a aprender representam o esforço de milhares de pessoas, realizado
durante muitos anos. Em outras palavras, você não está apenas aprendendo o &#8220;Symfony&#8221;,
você está aprendendo os fundamentos da web, boas práticas de desenvolvimento e
como usar diversas biblotecas PHP impressionantes, dentro e fora do Symfony2. Então,
prepare-se.</p>
<p>Seguindo a filosofia do Symfony2, este capítulo começa explicando o conceito fundamental
para o desenvolvimento web: o HTTP. Independente do seu conhecimento anterior ou
linguagem de programação preferida, esse capítulo é uma <strong>leitura obrigatória</strong>
para todos.</p>
<div class="section" id="http-e-simples">
<h2>HTTP é simples<a class="headerlink" href="#http-e-simples" title="Permalink to this headline">¶</a></h2>
<p>HTTP (Hypertext Transfer Protocol, para os geeks) é uma linguagem textual que
permite que duas máquinas se comuniquem entre si. É só isso! Por exemplo, quando
você vai ler a última tirinha do <a class="reference external" href="http://xkcd.com/">xkcd</a>, acontece mais ou menos a seguinte conversa:</p>
<img alt="../_images/http-xkcd.png" class="align-center" src="../_images/http-xkcd.png" />
<p>Apesar da linguagem real ser um pouco mais formal, ainda assim ela é bastante simples.
HTTP é o termo usado para descrever essa linguagem simples baseada em texto. Não
importa como você desenvolva para a web, o objetivo do seu servidor <em>sempre</em> será
entender simples requisições de texto e enviar simples respostas de texto.</p>
<p>O Symfony2 foi criado fundamentado nessa realidade. Você pode até não perceber,
mas o HTTP é algo que você utilizada todos os dias. Com o Symfony2 você irá
aprender a domina-lo.</p>
<div class="section" id="primeiro-passo-o-cliente-envia-uma-requisicao">
<span id="index-1"></span><h3>Primeiro Passo: O Cliente envia uma Requisição<a class="headerlink" href="#primeiro-passo-o-cliente-envia-uma-requisicao" title="Permalink to this headline">¶</a></h3>
<p>Toda comunicação na web começa com uma <em>requisição</em>. Ela é uma mensagem de texto
criada por um cliente (por exemplo, um navegador, um app para iPhone etc) em um
formato especial conhecido como HTTP. O cliente envia essa requisição para um
servidor e, então, espera pela resposta.</p>
<p>Veja a primeira parte da interação (a requisição) entre um navegador e o servidor
web do xkcd:</p>
<img alt="../_images/http-xkcd-request.png" class="align-center" src="../_images/http-xkcd-request.png" />
<p>No linguajar do HTTP, essa requisição se parece com isso:</p>
<div class="highlight-text"><div class="highlight"><pre>GET / HTTP/1.1
Host: xkcd.com
Accept: text/html
User-Agent: Mozilla/5.0 (Macintosh)
</pre></div>
</div>
<p>Essa simples mensagem comunica <em>tudo</em> o que é necessário sobre o recurso exato
que o cliente está requisitando. A primeira linha de uma requisição HTTP é a mais
importante e contém duas coisas: a URI e o método HTTP.</p>
<p>A URI (por exemplo, <tt class="docutils literal"><span class="pre">/</span></tt>, <tt class="docutils literal"><span class="pre">/contact</span></tt> etc) é um endereço único ou localização que
identifica o recurso que o cliente quer. O método HTTP (por exemplo, <tt class="docutils literal"><span class="pre">GET</span></tt>)
define o que você quer <em>fazer</em> com o recurso. Os métodos HTTP são os <em>verbos</em> da
requisição e definem algumas maneiras comuns de agir em relação ao recurso:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><em>GET</em></td>
<td>Recupera o recurso do servidor</td>
</tr>
<tr class="row-even"><td><em>POST</em></td>
<td>Cria um recurso no servidor</td>
</tr>
<tr class="row-odd"><td><em>PUT</em></td>
<td>Atualiza um recurso no servidor</td>
</tr>
<tr class="row-even"><td><em>DELETE</em></td>
<td>Exclui um recurso do servidor</td>
</tr>
</tbody>
</table>
<p>Tendo isso em mente, você pode imaginar como seria uma requisição HTTP para excluir
uma postagem específica de um blog, por exemplo:</p>
<div class="highlight-text"><div class="highlight"><pre>DELETE /blog/15 HTTP/1.1
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Existem na verdade nove métodos definidos pela especificação HTTP, mas
a maioria deles não são muito utilizados ou suportados. Na realidade, muitos dos
navegadores modernos não suportam os métodos <tt class="docutils literal"><span class="pre">PUT</span></tt> e <tt class="docutils literal"><span class="pre">DELETE</span></tt>.</p>
</div>
<p>Além da primeira linha, uma requisição HTTP invariavelmente contém outras linhas
de informação chamadas de cabeçalhos da requisição. Os cabeçalhos podem fornecer
uma vasta quantidade de informações, tais como o <tt class="docutils literal"><span class="pre">Host</span></tt> que foi requisitado, os
formatos de resposta que o cliente aceita (<tt class="docutils literal"><span class="pre">Accept</span></tt>) e a aplicação que o
cliente está utilizando para enviar a requisição (<tt class="docutils literal"><span class="pre">User-Agent</span></tt>). Muitos outros
cabeçalhos existem e podem ser encontrados na Wikipedia, no artigo
<a class="reference external" href="http://en.wikipedia.org/wiki/List_of_HTTP_header_fields">List of HTTP header fields</a></p>
</div>
<div class="section" id="segundo-passo-o-servidor-envia-uma-resposta">
<h3>Segundo Passo: O Servidor envia uma resposta<a class="headerlink" href="#segundo-passo-o-servidor-envia-uma-resposta" title="Permalink to this headline">¶</a></h3>
<p>Uma vez que o servidor recebeu uma requisição, ele sabe exatamente qual recurso
o cliente precisa (através do URI) e o que o cliente quer fazer com ele (através
do método). Por exemplo, no caso de uma requisição GET, o servidor prepara o
o recurso e o retorna em uma resposta HTTP. Considere a resposta do servidor web
do xkcd:</p>
<img alt="../_images/http-xkcd.png" class="align-center" src="../_images/http-xkcd.png" />
<p>Traduzindo para HTTP, a resposta enviada para o navegador será algo como:</p>
<div class="highlight-text"><div class="highlight"><pre>HTTP/1.1 200 OK
Date: Sat, 02 Apr 2011 21:05:05 GMT
Server: lighttpd/1.4.19
Content-Type: text/html

&lt;html&gt;
  &lt;!-- HTML for the xkcd comic --&gt;
&lt;/html&gt;
</pre></div>
</div>
<p>A resposta HTTP contém o recurso requisitado (nesse caso, o conteúdo HTML), bem
como outras informações. A primeira linha é especialmente importante e contém o
código de status da resposta HTTP (nesse caso, 200). Esse código de status é uma
representação geral da resposta enviada à requisição do cliente. A requisição
foi bem sucedida? Ocorreu algum erro? Existem diferentes códigos de status para
indentificar sucesso, um erro, ou que o cliente precisa fazer alguma coisa (por
exemplo, redirecionar para outra página). Uma lista completa pode ser encontrada
na Wikipedia, no artigo <a class="reference external" href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes">List of HTTP status codes</a>.</p>
<p>Assim como uma requisição, uma resposta HTTP também contém informações adicionais
conhecidas como cabeçalhos HTTP. Por exemplo, um cabeçalho importante nas respostas
HTTP é o <tt class="docutils literal"><span class="pre">Content-Type</span></tt>. O conteúdo de um mesmo recurso pode ser retornado em
vários formatos diferentes, incluindo HTML, XML ou JSON, só para citar alguns.
O cabeçalho <tt class="docutils literal"><span class="pre">Content-Type</span></tt> diz ao cliente qual é o formato que está sendo
retornado.</p>
<p>Existem diversos outros cabeçalhos, alguns deles bastante poderosos. Certos
cabeçalhos, por exemplo, podem ser utilizados para criar um poderoso sistema de
cache.</p>
</div>
<div class="section" id="requisicoes-respostas-e-o-desenvolvimento-web">
<h3>Requisições, Respostas e o Desenvolvimento Web<a class="headerlink" href="#requisicoes-respostas-e-o-desenvolvimento-web" title="Permalink to this headline">¶</a></h3>
<p>Essa conversação de requisição-resposta é o processo fundamental que dirige toda a
comunicação na web. Apesar de tão importante e poderoso esse processo, ainda assim,
é inevitavelmente simples.</p>
<p>O fato mais importante é: independente da linguagem que você utiliza, o tipo de
aplicação que você desenvolva (web, mobile, API em JSON) ou a filosofia de
desenvolvimento que você segue, o objetivo final da aplicação <strong>sempre</strong> será
entender cada requisição e criar e enviar uma resposta apropriada.</p>
<p>O Symfony foi arquitetado para atender essa realidade.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Para aprender mais sobre a especificação HTTP, leia o original <a class="reference external" href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">HTTP 1.1 RFC</a>
ou <a class="reference external" href="http://datatracker.ietf.org/wg/httpbis/">HTTP Bis</a>, que trata-se de um esforço para facilitar o entendimento da
especificação original. Para verificar as requisições e respostas enviadas
enquanto navega em um site, você pode utilizar a extensão do Firefox chamada
<a class="reference external" href="https://addons.mozilla.org/en-US/firefox/addon/3829/">Live HTTP Headers</a>.</p>
</div>
</div>
</div>
<div class="section" id="requisicoes-e-respostas-no-php">
<span id="index-2"></span><h2>Requisições e Respostas no PHP<a class="headerlink" href="#requisicoes-e-respostas-no-php" title="Permalink to this headline">¶</a></h2>
<p>Como interagir com a &#8220;requisição&#8221; e criar uma &#8220;resposta&#8221; utilizando o PHP? Na
verdade, o PHP abstrai um pouco desse processo:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="o">&lt;?</span><span class="nx">php</span>
<span class="nv">$uri</span> <span class="o">=</span> <span class="nv">$_SERVER</span><span class="p">[</span><span class="s1">&#39;REQUEST_URI&#39;</span><span class="p">];</span>
<span class="nv">$foo</span> <span class="o">=</span> <span class="nv">$_GET</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">];</span>

<span class="nx">header</span><span class="p">(</span><span class="s1">&#39;Content-type: text/html&#39;</span><span class="p">);</span>
<span class="k">echo</span> <span class="s1">&#39;The URI requested is: &#39;</span><span class="o">.</span><span class="nv">$uri</span><span class="p">;</span>
<span class="k">echo</span> <span class="s1">&#39;The value of the &quot;foo&quot; parameter is: &#39;</span><span class="o">.</span><span class="nv">$foo</span><span class="p">;</span>
</pre></div>
</div>
<p>Por mais estranho que possa parecer, essa pequena aplicação, de fato, lê
informações da requisição HTTP e a está utilizando para criar um resposta HTTP. Em
vez de interpretar a requisição pura, o PHP prepara algumas variáveis superglobais
, tais como <tt class="docutils literal"><span class="pre">$_SERVER</span></tt> e <tt class="docutils literal"><span class="pre">$_GET</span></tt>, que contém toda a informação da requisição.
Da mesma forma, em vez de retornar o texto da resposta no formato do HTTP, você
pode utilizar a função <tt class="docutils literal"><span class="pre">header()</span></tt> para criar os cabeçalhos e simplesmente
imprimir o que será o conteúdo da mensagem da reposta. O PHP irá criar uma
reposta HTTP verdadeira que será retornada para o cliente.</p>
<div class="highlight-text"><div class="highlight"><pre>HTTP/1.1 200 OK
Date: Sat, 03 Apr 2011 02:14:33 GMT
Server: Apache/2.2.17 (Unix)
Content-Type: text/html

The URI requested is: /testing?foo=symfony
The value of the &quot;foo&quot; parameter is: symfony
</pre></div>
</div>
</div>
<div class="section" id="requisicoes-e-respostas-no-symfony">
<h2>Requisições e Respostas no Symfony<a class="headerlink" href="#requisicoes-e-respostas-no-symfony" title="Permalink to this headline">¶</a></h2>
<p>O Symfony fornece uma alternativa à abordagem feita com o PHP puro, utilizando
duas classes que permitem a interação com as requisições e respostas HTTP de uma
maneira mais fácil. A classe <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpFoundation/Request.html" title="Symfony\Component\HttpFoundation\Request"><span class="pre">Request</span></a></tt>
é uma simples representação orientada a objetos de uma requisição HTTP. Com ela,
você tem todas as informações da requisição nas pontas dos dedos:</p>
<div class="highlight-python"><pre>use Symfony\Component\HttpFoundation\Request;

$request = Request::createFromGlobals();

// the URI being requested (e.g. /about) minus any query parameters
$request-&gt;getPathInfo();

// retrieve GET and POST variables respectively
$request-&gt;query-&gt;get('foo');
$request-&gt;request-&gt;get('bar');

// retrieves an instance of UploadedFile identified by foo
$request-&gt;files-&gt;get('foo');

$request-&gt;getMethod();          // GET, POST, PUT, DELETE, HEAD
$request-&gt;getLanguages();       // an array of languages the client accepts</pre>
</div>
<p>Como um bônus, a classe <tt class="docutils literal"><span class="pre">Request</span></tt> faz um monte de trabalho com o qual você
nunca precisará se preocupar. Por exemplo, o método <tt class="docutils literal"><span class="pre">isSecure()</span></tt> verifica os
três valores diferentes que o PHP utiliza para indicar ser o usuário está
utilizando uma conexão segura (<tt class="docutils literal"><span class="pre">https</span></tt>, por exemplo).</p>
<p>O Symfony também fornece a classe <tt class="docutils literal"><span class="pre">Response</span></tt>: uma simples representação em PHP de
uma resposta HTTP. Assim é possível que sua aplicação utilize uma interface
orientada a objetos para construir a resposta que precisa ser enviada ao cliente:</p>
<div class="highlight-python"><pre>use Symfony\Component\HttpFoundation\Response;
$response = new Response();

$response-&gt;setContent('&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');
$response-&gt;setStatusCode(200);
$response-&gt;headers-&gt;set('Content-Type', 'text/html');

// prints the HTTP headers followed by the content
$response-&gt;send();</pre>
</div>
<p>Com tudo isso, mesmo que o Symfony não oferecesse mais nada, você já teria um kit de
ferramentas para facilmente acessar informações sobre a requisição e uma interface
orientada a objetos para criar a resposta. Mesmo depois de aprender muitos dos
poderosos recursos do Symfony, tenha em mente que o objetivo da sua aplicação
sempre será <em>interpretar uma requisição e criar a resposta apropriada baseada na
lógica da sua aplicação</em>.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">As classes <tt class="docutils literal"><span class="pre">Request</span></tt> e <tt class="docutils literal"><span class="pre">Response</span></tt> fazem parte de um componente do Symfony
chamado <tt class="docutils literal"><span class="pre">HttpFoundation</span></tt>. Esse componente pode ser utilizado de forma
independente ao framework e também possui classes para tratar sessões e
upload de arquivos.</p>
</div>
</div>
<div class="section" id="a-jornada-da-requisicao-ate-a-resposta">
<h2>A Jornada da Requisição até a Resposta<a class="headerlink" href="#a-jornada-da-requisicao-ate-a-resposta" title="Permalink to this headline">¶</a></h2>
<p>Como o próprio HTTP, os objetos <tt class="docutils literal"><span class="pre">Request</span></tt> e <tt class="docutils literal"><span class="pre">Response</span></tt> são bastante simples.
A parte difícil de se construir uma aplicação é escrever o que acontece entre eles.
Em outras palavras, o trabalho de verdade é escrever o código que interpreta a
a requisição e cria a resposta.</p>
<p>A sua aplicação provavelmente faz muitas coisas como enviar emails, tratar do
envio de formulários, salvar coisas no banco de dados, renderizar páginas HTML e
proteger o conteúdo com segurança. Como cuidar de tudo isso e ainda ter um código
organizado e de fácil manutenção?</p>
<p>O Symfony foi criado para que ele resolva esses problemas, não você.</p>
<div class="section" id="o-front-controller">
<h3>O Front Controller<a class="headerlink" href="#o-front-controller" title="Permalink to this headline">¶</a></h3>
<p>Tradicionalmente, aplicações são construídas para que cada página do site seja
um arquivo físico:</p>
<div class="highlight-text"><div class="highlight"><pre>index.php
contact.php
blog.php
</pre></div>
</div>
<p>Existem diversos problemas para essa abordagem, incluindo a falta de flexibilidade
das URLs (e se você quiser mudar o arquivo <tt class="docutils literal"><span class="pre">blog.php</span></tt> para <tt class="docutils literal"><span class="pre">news.php</span></tt> sem
quebrar todos os seus links?) e o fato de que cada arquivo <em>deve</em> ser alterado
manualmente para incluir um certo conjunto de arquivos essenciais de forma que a
segurança, conexões com banco de dados e a &#8220;aparência&#8221; do site continue consistente.</p>
<p>Uma solução muito melhor é utilizar um <em class="xref std std-term">front controller</em>: um único arquivo
PHP que trata todas as requisições enviadas para a sua aplicação. Por exemplo:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">/index.php</span></tt></td>
<td>executa  <tt class="docutils literal"><span class="pre">index.php</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">/index.php/contact</span></tt></td>
<td>executa  <tt class="docutils literal"><span class="pre">index.php</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">/index.php/blog</span></tt></td>
<td>executa  <tt class="docutils literal"><span class="pre">index.php</span></tt></td>
</tr>
</tbody>
</table>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Utilizando o <tt class="docutils literal"><span class="pre">mod_rewrite</span></tt> do Apache (ou o equivalente em outros servidores
web), as URLs podem ser simplificadas facilmente para ser somente <tt class="docutils literal"><span class="pre">/</span></tt>, <tt class="docutils literal"><span class="pre">/contact</span></tt>
e <tt class="docutils literal"><span class="pre">/blog</span></tt>.</p>
</div>
<p>Agora, cada requisição é tratada exatamente do mesmo jeito. Em vez de arquivos
PHP individuais para executar cada URL, o front controller <em>sempre</em> será executado,
e o roteamento de cada URL para diferentes partes da sua aplicação é feito internamente.
Assim resolve-se os dois problemas da abordagem original. Quase todas as aplicações
modernas fazem isso - incluindo apps como o Wordpress.</p>
</div>
<div class="section" id="mantenha-se-organizado">
<h3>Mantenha-se Organizado<a class="headerlink" href="#mantenha-se-organizado" title="Permalink to this headline">¶</a></h3>
<p>Dentro do front controller, como você sabe qual página deve ser renderizada e como
renderiza-las de uma maneira sensata? De um jeito ou de outro, você precisará
verificar a URI requisitada e executar partes diferentes do seu código dependendo
do seu valor. Isso pode acabar ficando feio bem rápido:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// index.php</span>

<span class="nv">$request</span> <span class="o">=</span> <span class="nx">Request</span><span class="o">::</span><span class="na">createFromGlobals</span><span class="p">();</span>
<span class="nv">$path</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getPathInfo</span><span class="p">();</span> <span class="c1">// the URL being requested</span>

<span class="k">if</span> <span class="p">(</span><span class="nb">in_array</span><span class="p">(</span><span class="nv">$path</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">))</span> <span class="p">{</span>
    <span class="nv">$response</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">(</span><span class="s1">&#39;Welcome to the homepage.&#39;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">elseif</span> <span class="p">(</span><span class="nv">$path</span> <span class="o">==</span> <span class="s1">&#39;/contact&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$response</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">(</span><span class="s1">&#39;Contact us&#39;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nv">$response</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">(</span><span class="s1">&#39;Page not found.&#39;</span><span class="p">,</span> <span class="mi">404</span><span class="p">);</span>
<span class="p">}</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">();</span>
</pre></div>
</div>
<p>Resolver esse problema pode ser difícil. Felizmente é <em>exatamente</em> o que o Symfony
foi projetado para fazer.</p>
</div>
<div class="section" id="o-fluxo-de-uma-aplicacao-symfony">
<h3>O Fluxo de uma Aplicação Symfony<a class="headerlink" href="#o-fluxo-de-uma-aplicacao-symfony" title="Permalink to this headline">¶</a></h3>
<p>Quando você deixa que o Symfony cuide de cada requisição, sua vida fica muito mais
fácil. O framework segue um simples padrão para toda requisição:</p>
<div class="figure align-center" id="request-flow-figure">
<img alt="Symfony2 request flow" src="../_images/request-flow.png" />
<p class="caption">As requisições recebidas são interpretadas pelo roteamento e passadas para as
funções controller que retornam objetos do tipo <tt class="docutils literal"><span class="pre">Response</span></tt>.</p>
</div>
<p>Cada &#8220;página&#8221; do seu site é definida no arquivo de configuração de roteamento que
mapeia diferentes URLs para diferentes funções PHP. O trabalho de cada função,
chamadas de <em class="xref std std-term">controller</em>, é usar a informação da requisição - junto com
diversas outras ferramentas disponíveis no Symfony - para criar e retornar um
objeto <tt class="docutils literal"><span class="pre">Response</span></tt>. Em outras palavras, o <em>seu</em> código deve estar nas funções controller:
lá é onde você interpreta a requisição e cria uma resposta.</p>
<p>É fácil! Vamos fazer uma revisão:</p>
<ul class="simple">
<li>Cada requisição executa um arquivo front controller;</li>
<li>O sistema de roteamento determina qual função PHP deve ser executada, baseado
na informação da requisição e na configuração de roteamento que você criou;</li>
<li>A função PHP correta é executada, onde o seu código cria e retorna o objeto
<tt class="docutils literal"><span class="pre">Response</span></tt> apropriado.</li>
</ul>
</div>
<div class="section" id="uma-requisicao-symfony-em-acao">
<h3>Uma Requisição Symfony em Ação<a class="headerlink" href="#uma-requisicao-symfony-em-acao" title="Permalink to this headline">¶</a></h3>
<p>Sem entrar em muitos detalhes, vamos ver esse processo em ação. Suponha que
você quer adicionar a página <tt class="docutils literal"><span class="pre">/contact</span></tt> na sua aplicação Symfony. Primeiro,
adicione uma entrada para <tt class="docutils literal"><span class="pre">/contact</span></tt> no seu arquivo de configuração de roteamento:</p>
<div class="highlight-yaml"><div class="highlight"><pre><span class="l-Scalar-Plain">contact</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">pattern</span><span class="p-Indicator">:</span>  <span class="l-Scalar-Plain">/contact</span>
    <span class="l-Scalar-Plain">defaults</span><span class="p-Indicator">:</span> <span class="p-Indicator">{</span> <span class="nv">_controller</span><span class="p-Indicator">:</span> <span class="nv">AcmeDemoBundle</span><span class="p-Indicator">:</span><span class="nv">Main</span><span class="p-Indicator">:</span><span class="nv">contact</span> <span class="p-Indicator">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Esse exemplo utiliza <tt class="xref doc docutils literal"><span class="pre">YAML</span></tt> para definir a configuração de
roteamento. Essa configuração também pode ser escrita em outros formatos, tais
como XML ou PHP.</p>
</div>
<p>Quando alguém visitar a página <tt class="docutils literal"><span class="pre">/contact</span></tt>, essa rota será encontrada e o
controller específico será executado. Como você irá aprender no <a class="reference internal" href="routing.html"><em>capítulo sobre roteamento</em></a>,
a string <tt class="docutils literal"><span class="pre">AcmeDemoBundle:Main:contact</span></tt> é uma sintaxe encurtada para apontar para
o método <tt class="docutils literal"><span class="pre">contactAction</span></tt> dentro de uma classe chamada <tt class="docutils literal"><span class="pre">MainController</span></tt>:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MainController</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">contactAction</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">(</span><span class="s1">&#39;&lt;h1&gt;Contact us!&lt;/h1&gt;&#39;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Nesse exemplo extremamente simples, o controller simplesmente cria um objeto
<tt class="docutils literal"><span class="pre">Response</span></tt> com o HTML &#8220;&lt;h1&gt;Contact us!&lt;/h1&gt;&#8221;. No <a class="reference internal" href="controller.html"><em>capítulo sobre controller</em></a>,
você irá aprender como um controller pode renderizar templates, fazendo com que o seu código de
&#8220;apresentação&#8221; (por exemplo, qualquer coisa que gere HTML) fique em um arquivo de
template separado. Assim deixamos o controller livre para se preocupar apenas com
a parte complicada: interagir com o banco de dados, tratar os dados enviados ou
enviar emails.</p>
</div>
</div>
<div class="section" id="symfony2-construa-sua-aplicacao-nao-suas-ferramentas">
<h2>Symfony2: Construa sua aplicação, não suas Ferramentas<a class="headerlink" href="#symfony2-construa-sua-aplicacao-nao-suas-ferramentas" title="Permalink to this headline">¶</a></h2>
<p>Agora você sabe que o objetivo de qualquer aplicação é interpretar cada requisição
recebida e criar uma resposta apropriada. Conforme uma aplicação cresce, torna-se
mais difícil de manter o seu código organizado e de fácil manutenção. Invariavelmente,
as mesmas tarefas complexas continuam a aparecer: persistir dados no banco,
renderizar e reutilizar templates, tratar envios de formulários, enviar emails,
validar entradas dos usuários e cuidar da segurança.</p>
<p>A boa notícia é que nenhum desses problemas é único. O Symfony é um framework cheio
de ferramentas para você construir a sua aplicação e não as suas ferramentas.
Com o Symfony2, nada é imposto: você é livre para utilizar o framework completo ou
apenas uma parte dele.</p>
<div class="section" id="ferramentas-independentes-os-componentes-do-symfony2">
<span id="index-3"></span><h3>Ferramentas Independentes: Os <em>Componentes</em> do Symfony2<a class="headerlink" href="#ferramentas-independentes-os-componentes-do-symfony2" title="Permalink to this headline">¶</a></h3>
<p>Então, o que <em>é</em> o Symfony2? Primeiramente, trata-se de uma coleção de vinte
bibliotecas independentes que podem ser utilizadas dentro de <em>qualquer</em> projeto
PHP. Essas bibliotecas, chamadas de <em>Components do Symfony2</em>, contém coisas úteis
para praticamente qualquer situação, independente de como o seu projeto é desenvolvido.
Alguns desses componentes são:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/symfony/HttpFoundation">HttpFoundation</a> - Contém as classes <tt class="docutils literal"><span class="pre">Request</span></tt> e <tt class="docutils literal"><span class="pre">Response</span></tt>, bem como outras
classes para tratar de sessões e upload de arquivos;</li>
<li><a class="reference external" href="https://github.com/symfony/Routing">Routing</a> - Um poderoso e rápido sistema de roteamento que permite mapear uma
URI específica (por exemplo, <tt class="docutils literal"><span class="pre">/contact</span></tt>) para uma informação sobre como a
requisição deve ser tratada (por exemplo, executar o método <tt class="docutils literal"><span class="pre">contactAction()</span></tt>);</li>
<li><a class="reference external" href="https://github.com/symfony/Form">Form</a> - Um framework completo e flexível para criar formulários e tratar os
dados enviados por eles;</li>
<li><a class="reference external" href="https://github.com/symfony/Validator">Validator</a> Um sistema para criar regras sobre dados e validar se os dados
enviados pelos usuários seguem ou não essas regras;</li>
<li><a class="reference external" href="https://github.com/symfony/ClassLoader">ClassLoader</a> Uma biblioteca de autoloading que faz com que classes PHP possam
ser utilizadas sem precisar adicionar manualmente um <tt class="docutils literal"><span class="pre">require</span></tt> para cada arquivo
que as contém;</li>
<li><a class="reference external" href="https://github.com/symfony/Templating">Templating</a> Um conjunto de ferramentas para renderizar templates, tratar da
herança de templates (por exemplo, um template decorado com um layout) e executar
outras tarefas comuns relacionadas a templates;</li>
<li><a class="reference external" href="https://github.com/symfony/Security">Security</a> - Uma biblioteca poderosa para tratar qualquer tipo de segurança
dentro de sua aplicação;</li>
<li><a class="reference external" href="https://github.com/symfony/Translation">Translation</a> Um framework para traduzir strings na sua aplicação.</li>
</ul>
<p>Cada um desses componentes funcionam de forma independente e podem ser utilizados
em <em>qualquer</em> projeto PHP, não importa se você utiliza o Symfony2 ou não. Cada
parte foi feita para ser utilizada e substituída quando for necessário.</p>
</div>
<div class="section" id="a-solucao-completa-o-framework-symfony2">
<h3>A solução completa: O <em>framework</em> Symfony2<a class="headerlink" href="#a-solucao-completa-o-framework-symfony2" title="Permalink to this headline">¶</a></h3>
<p>Então, o que <em>é</em> o <em>framework</em> Symfony2? Ele é uma biblioteca PHP que realiza
duas tarefas distintas:</p>
<ol class="arabic simple">
<li>Fornecer uma seleção de componentes (os componentes do Symfony2, por exemplo) e
bibliotecas de terceiros (por exemplo, a <tt class="docutils literal"><span class="pre">Swiftmailer</span></tt>, utilizada para enviar emails);</li>
<li>Fornecer as configurações necessárias e uma &#8220;cola&#8221; para manter todas as peças
juntas.</li>
</ol>
<p>O objetivo do framework é integrar várias ferramentas independentes para criar
uma experiência consistente para o desenvolvedor. Até próprio próprio framework é
um pacote Symfony2 (um plugin, por exemplo) que pode ser configurado ou completamente
substituído.</p>
<p>O Symfony2 fornece um poderoso conjunto de ferramentas para desenvolver aplicações
web rapidamente sem impor nada. Usuários normais podem iniciar o desenvolvimento rapidamente
utilizando uma distribuição do Symfony2, que contém o esqueleto de um projeto com
as princpais itens padrão. Para os usuários mais avançados, o céu é o limite.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Fundamentos de Symfony e HTTP</a><ul>
<li><a class="reference internal" href="#http-e-simples">HTTP é simples</a><ul>
<li><a class="reference internal" href="#primeiro-passo-o-cliente-envia-uma-requisicao">Primeiro Passo: O Cliente envia uma Requisição</a></li>
<li><a class="reference internal" href="#segundo-passo-o-servidor-envia-uma-resposta">Segundo Passo: O Servidor envia uma resposta</a></li>
<li><a class="reference internal" href="#requisicoes-respostas-e-o-desenvolvimento-web">Requisições, Respostas e o Desenvolvimento Web</a></li>
</ul>
</li>
<li><a class="reference internal" href="#requisicoes-e-respostas-no-php">Requisições e Respostas no PHP</a></li>
<li><a class="reference internal" href="#requisicoes-e-respostas-no-symfony">Requisições e Respostas no Symfony</a></li>
<li><a class="reference internal" href="#a-jornada-da-requisicao-ate-a-resposta">A Jornada da Requisição até a Resposta</a><ul>
<li><a class="reference internal" href="#o-front-controller">O Front Controller</a></li>
<li><a class="reference internal" href="#mantenha-se-organizado">Mantenha-se Organizado</a></li>
<li><a class="reference internal" href="#o-fluxo-de-uma-aplicacao-symfony">O Fluxo de uma Aplicação Symfony</a></li>
<li><a class="reference internal" href="#uma-requisicao-symfony-em-acao">Uma Requisição Symfony em Ação</a></li>
</ul>
</li>
<li><a class="reference internal" href="#symfony2-construa-sua-aplicacao-nao-suas-ferramentas">Symfony2: Construa sua aplicação, não suas Ferramentas</a><ul>
<li><a class="reference internal" href="#ferramentas-independentes-os-componentes-do-symfony2">Ferramentas Independentes: Os <em>Componentes</em> do Symfony2</a></li>
<li><a class="reference internal" href="#a-solucao-completa-o-framework-symfony2">A solução completa: O <em>framework</em> Symfony2</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Livro</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="from_flat_php_to_symfony2.html"
                        title="next chapter">Symfony2 versus o PHP puro</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/book/http_fundamentals.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="from_flat_php_to_symfony2.html" title="Symfony2 versus o PHP puro"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Livro"
             >previous</a> |</li>
        <li><a href="../index.html">Symfony2Docs 2.0.x documentation</a> &raquo;</li>
          <li><a href="index.html" >Livro</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Symfony Team.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>