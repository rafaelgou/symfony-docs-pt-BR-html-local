<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Bastidores &mdash; Symfony2.4Docs 2.4 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Symfony2.4Docs 2.4 documentation" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="../index.html">Symfony2.4Docs 2.4 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <p>single: Bastidores</p>
<div class="section" id="bastidores">
<h1>Bastidores<a class="headerlink" href="#bastidores" title="Permalink to this headline">¶</a></h1>
<p>Parece que você quer entender como funciona o Symfony2 e como extendê-lo.
Isso me deixa muito feliz! Esta seção explica detalhadamente os bastidores
do Symfony2.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Você precisa ler esta seção apenas se quer entender como o Symfony2 funciona
seu miolo, ou se quer extendê-lo.</p>
</div>
<div class="section" id="visao-geral">
<h2>Visão Geral<a class="headerlink" href="#visao-geral" title="Permalink to this headline">¶</a></h2>
<p>O código do Symfony2 é feito de várias camadas independentes. Cada camada é
construída em cima da anterior.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">O Autoloading não é gerenciado diretamente pelo framework; isso é feito usando
o autoloader do Composer (<tt class="docutils literal"><span class="pre">vendor/autoload.php</span></tt>), que é incluído no arquivo
<tt class="docutils literal"><span class="pre">app/autoload.php</span></tt>.</p>
</div>
<div class="section" id="componente-httpfoundation">
<h3>Componente <tt class="docutils literal"><span class="pre">HttpFoundation</span></tt><a class="headerlink" href="#componente-httpfoundation" title="Permalink to this headline">¶</a></h3>
<p>O nível mais profundo é o componente <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpFoundation.html" title="Symfony\Component\HttpFoundation"><span class="pre">HttpFoundation</span></a></tt>.
HttpFoundation fornece os principais objetos necessários para lidar com HTTP.
É um objeto que abstrai algumas funções nativas do PHP e variáveis:</p>
<ul class="simple">
<li>A classe <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpFoundation/Request.html" title="Symfony\Component\HttpFoundation\Request"><span class="pre">Request</span></a></tt> abstrai as principais
variáveis globais do PHP como: <tt class="docutils literal"><span class="pre">$_GET</span></tt>, <tt class="docutils literal"><span class="pre">$_POST</span></tt>, <tt class="docutils literal"><span class="pre">$_COOKIE</span></tt>,
<tt class="docutils literal"><span class="pre">$_FILES</span></tt>, e <tt class="docutils literal"><span class="pre">$_SERVER</span></tt>;</li>
<li>A classe <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpFoundation/Response.html" title="Symfony\Component\HttpFoundation\Response"><span class="pre">Response</span></a></tt> abstrai algumas
funções do PHP como: <tt class="docutils literal"><span class="pre">header()</span></tt>, <tt class="docutils literal"><span class="pre">setcookie()</span></tt>, e <tt class="docutils literal"><span class="pre">echo</span></tt>;</li>
<li>A classe <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpFoundation/Session.html" title="Symfony\Component\HttpFoundation\Session"><span class="pre">Session</span></a></tt> e a interface
<tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpFoundation/SessionStorage/SessionStorageInterface.html" title="Symfony\Component\HttpFoundation\SessionStorage\SessionStorageInterface"><span class="pre">SessionStorageInterface</span></a></tt>
abstraem o gerenciamento da sessão, com uso das funções <tt class="docutils literal"><span class="pre">session_*()</span></tt>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Leia mais sobre o <tt class="xref doc docutils literal"><span class="pre">Componente</span> <span class="pre">HttpFoundation</span></tt>.</p>
</div>
</div>
<div class="section" id="componente-httpkernel">
<h3>Componente <tt class="docutils literal"><span class="pre">HttpKernel</span></tt><a class="headerlink" href="#componente-httpkernel" title="Permalink to this headline">¶</a></h3>
<p>No topo do HttpFoundation está o componente <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel.html" title="Symfony\Component\HttpKernel"><span class="pre">HttpKernel</span></a></tt>.
HttpKernel manuseia a parte dinâmica do HTTP; é um sutíl que envolve as classes
Request e Response para padronizar as formas como as requisições são manipuladas. Ele
também oferece pontos de extensão e ferramentas ideais para criar um framework Web
sem muito trabalho.</p>
<p>Também, opcionalmente, adiciona conigurabilidade e extensibilidade, obrigado ao
componente de Injeção de Dependência e um poderoso sistema de plugins (bundles).</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Leia mais sobre o <tt class="xref doc docutils literal"><span class="pre">Componente</span> <span class="pre">HttpKernel</span></tt>,
<a class="reference internal" href="service_container.html"><em>Dependency Injection</em></a> e
<a class="reference internal" href="../cookbook/bundles/best_practices.html"><em>Bundles</em></a>.</p>
</div>
</div>
<div class="section" id="o-bundle-frameworkbundle">
<h3>O Bundle <tt class="docutils literal"><span class="pre">FrameworkBundle</span></tt><a class="headerlink" href="#o-bundle-frameworkbundle" title="Permalink to this headline">¶</a></h3>
<p>O bundle <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Bundle/FrameworkBundle.html" title="Symfony\Bundle\FrameworkBundle"><span class="pre">FrameworkBundle</span></a></tt> é um pacote que amarra os
principais componentes e bibliotecas para fazer um leve e rápido framework MVC. Ele
vem com uma configuração padrão e convenções para facilitar a curva de aprendizado.</p>
<p>single: Bastidores; Kernel</p>
</div>
</div>
<div class="section" id="kernel">
<h2>Kernel<a class="headerlink" href="#kernel" title="Permalink to this headline">¶</a></h2>
<p>A classe <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/HttpKernel.html" title="Symfony\Component\HttpKernel\HttpKernel"><span class="pre">HttpKernel</span></a></tt> é a classe central
do Symfony2 e é responsável por tratar os peedidos do cliente. Seu principal objetivo
é &#8220;converter&#8221; um objeto <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpFoundation/Request.html" title="Symfony\Component\HttpFoundation\Request"><span class="pre">Request</span></a></tt> para um
objeto <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpFoundation/Response.html" title="Symfony\Component\HttpFoundation\Response"><span class="pre">Response</span></a></tt>.</p>
<p>Cada Kernel do Symfony2 implementa
<tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/HttpKernelInterface.html" title="Symfony\Component\HttpKernel\HttpKernelInterface"><span class="pre">HttpKernelInterface</span></a></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true)
</pre></div>
</div>
<p>single: Bastidores; Resolvedor do Controlador</p>
<div class="section" id="controladores">
<h3>Controladores<a class="headerlink" href="#controladores" title="Permalink to this headline">¶</a></h3>
<p>Para converter um Request para um Response, o Kernel se baseia em um &#8220;Controlador&#8221;. Um
Controlador pode ser qualquer código PHP válido.</p>
<p>O Controlador deve ser uma implementação de
<tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/Controller/ControllerResolverInterface.html" title="Symfony\Component\HttpKernel\Controller\ControllerResolverInterface"><span class="pre">ControllerResolverInterface</span></a></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>public function getController(Request $request);

public function getArguments(Request $request, $controller);
</pre></div>
</div>
<p>e o Kernel poderá executá-lo.</p>
<p>O método
<tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/Controller/ControllerResolverInterface.html#method_getController" title="Symfony\Component\HttpKernel\Controller\ControllerResolverInterface::getController()"><span class="pre">getController()</span></a></tt>
retorna o Controlador (um código PHP) associado com o dado Request. A implementação padrão
(<tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/Controller/ControllerResolver.html" title="Symfony\Component\HttpKernel\Controller\ControllerResolver"><span class="pre">ControllerResolver</span></a></tt>) procura
pelo atributo <tt class="docutils literal"><span class="pre">_controller</span></tt> do pedido que representa o nome do controlador
(uma string &#8220;classs::método&#8221;, como <tt class="docutils literal"><span class="pre">Bundle\BlogBundle\PostController:indexAction</span></tt>).</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">A implementação padrão utiliza o
<tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Bundle/FrameworkBundle/EventListener/RouterListener.html" title="Symfony\Bundle\FrameworkBundle\EventListener\RouterListener"><span class="pre">RouterListener</span></a></tt>
para definir o atributo <tt class="docutils literal"><span class="pre">_controller</span></tt> do Request (veja <a class="reference internal" href="#kernel-core-request"><em>Evento kernel.request</em></a>).</p>
</div>
<p>O método
<tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/Controller/ControllerResolverInterface.html#method_getArguments" title="Symfony\Component\HttpKernel\Controller\ControllerResolverInterface::getArguments()"><span class="pre">getArguments()</span></a></tt>
retorna um arrau de argumentos para passar para o Controlador. A implementação padrão
automaticamente resolve os argumentos dos métodos, baseado nos atributos do Request.</p>
<p>atributos do Request</p>
<blockquote>
<div><p>Para cada argumento, o Symfony2 tenta pegar o valor do atributo do Request com o
mesmo nome. Se este não estiver definido, o valor do argumento padrão é usado se
definido:</p>
<div class="highlight-python"><div class="highlight"><pre>// Symfony2 vai olhar para um atributo &#39;id&#39; (obrigatório)
// e um &#39;admin&#39; (opcional)
public function showAction($id, $admin = true)
{
    // ...
}
</pre></div>
</div>
</div></blockquote>
<p>single: Bastidores; Trantando os Requests</p>
</div>
<div class="section" id="trantando-os-requests">
<h3>Trantando os Requests<a class="headerlink" href="#trantando-os-requests" title="Permalink to this headline">¶</a></h3>
<p>O método <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/HttpKernel.html#method_handle" title="Symfony\Component\HttpKernel\HttpKernel::handle()"><span class="pre">handle()</span></a></tt> pega um
<tt class="docutils literal"><span class="pre">Request</span></tt> e <em>sempre</em> retorna um <tt class="docutils literal"><span class="pre">Response</span></tt>. Para converter o <tt class="docutils literal"><span class="pre">Request</span></tt>,
o <tt class="docutils literal"><span class="pre">handle()</span></tt> depende do Resolver e uma cadeia ordenada de notificações de eventos
(veja a próxima seção para mais informações sobre cada Event):</p>
<ol class="arabic simple">
<li>Antes de qualquer coisa, o evento <tt class="docutils literal"><span class="pre">kernel.request</span></tt> é notificado &#8211; se um dos
listeners retorna um <tt class="docutils literal"><span class="pre">Response</span></tt>, pula diretamente para o passo 8;</li>
<li>O Resolver é chamado para determinar qual Controlador executar;</li>
<li>Os listeners do evento <tt class="docutils literal"><span class="pre">kernel.controller</span></tt> podem manipular o Controlador
chamado como queiram (alterá-lo, envolvê-lo, ...);</li>
<li>O Kernel verifica se o Controlador é um código PHP válido;</li>
<li>O Resolver é chamado para determinar os argumentos para passar para o Controlador;</li>
<li>O Kernel chama o Controlador;</li>
<li>Se o Controlador não retorna um <tt class="docutils literal"><span class="pre">Response</span></tt>, os listeners do evento
<tt class="docutils literal"><span class="pre">kernel.view</span></tt> podem converter o valor de retorno do Controlador para um <tt class="docutils literal"><span class="pre">Response</span></tt>;</li>
<li>Os listeners do evento <tt class="docutils literal"><span class="pre">kernel.response</span></tt> podem manipular o <tt class="docutils literal"><span class="pre">Response</span></tt>
(conteúdo e cabeçalho);</li>
<li>O Response é retornado.</li>
</ol>
<p>Se uma Exception é lançada durante o processamento, o <tt class="docutils literal"><span class="pre">kernel.exception</span></tt> é notificado
e os listeners têm a oportundade de converter a Exception em um Response. Se isso
funcionar, o evento <tt class="docutils literal"><span class="pre">kernel.reponse</span></tt> é notificado; se não, a Exception é relançada.</p>
<p>Se você não quer ser pego por uma Exception (para pedidos embutido por exemplo),
desabilite o evento <tt class="docutils literal"><span class="pre">kernel.exception</span></tt> pasando <tt class="docutils literal"><span class="pre">false</span></tt> como o terceiro argumento
do método <tt class="docutils literal"><span class="pre">handle()</span></tt>.</p>
<p>single: Bastidores; Requests Internos</p>
</div>
<div class="section" id="requests-internos">
<h3>Requests Internos<a class="headerlink" href="#requests-internos" title="Permalink to this headline">¶</a></h3>
<p>A qualquer momento durante o tratamento de um pedido (o &#8216;master&#8217;), um sub-pedido
pode ser manipulado. Você pode passar o tipo do pedido para o método <tt class="docutils literal"><span class="pre">handle()</span></tt>
(segundo argumento):</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">HttpKernelInterface::MASTER_REQUEST</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">HttpKernelInterface::SUB_REQUEST</span></tt>.</li>
</ul>
<p>O tipo é passado para todos os eventos e os listeners podem agir de acordo (alguns
processamentos só devem ocorrer no pedido principal).</p>
<p>pair: Kernel; Evento</p>
</div>
<div class="section" id="eventos">
<h3>Eventos<a class="headerlink" href="#eventos" title="Permalink to this headline">¶</a></h3>
<p>Cada evento acionado pelo Kernel é uma subclasse do
<tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/Event/KernelEvent.html" title="Symfony\Component\HttpKernel\Event\KernelEvent"><span class="pre">KernelEvent</span></a></tt>. Isto significa que cada
evento tem acesso para a mesma informação básica:</p>
<ul class="simple">
<li><tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/Event/KernelEvent.html#method_getRequestType" title="Symfony\Component\HttpKernel\Event\KernelEvent::getRequestType()"><span class="pre">getRequestType()</span></a></tt>
- retorna o <em>tipo</em> do pedido (<tt class="docutils literal"><span class="pre">HttpKernelInterface::MASTER_REQUEST</span></tt>
ou <tt class="docutils literal"><span class="pre">HttpKernelInterface::SUB_REQUEST</span></tt>);</li>
<li><tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/Event/KernelEvent.html#method_getKernel" title="Symfony\Component\HttpKernel\Event\KernelEvent::getKernel()"><span class="pre">getKernel()</span></a></tt>
- retorna o Kernel manipulando o pedido;</li>
<li><tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/Event/KernelEvent.html#method_getRequest" title="Symfony\Component\HttpKernel\Event\KernelEvent::getRequest()"><span class="pre">getRequest()</span></a></tt>
- retorna o <tt class="docutils literal"><span class="pre">Request</span></tt> sendo manipulado.</li>
</ul>
<div class="section" id="getrequesttype">
<h4><tt class="docutils literal"><span class="pre">getRequestType()</span></tt><a class="headerlink" href="#getrequesttype" title="Permalink to this headline">¶</a></h4>
<p>O método <tt class="docutils literal"><span class="pre">getRequestType()</span></tt> permite os listeners para a saber o tipo do pedido.
Por exemple, se um listener só deve estar ativo para um pedidos principais, adicione
o seguinte código no início do seu método listener:</p>
<div class="highlight-python"><div class="highlight"><pre>use Symfony\Component\HttpKernel\HttpKernelInterface;

if (HttpKernelInterface::MASTER_REQUEST !== $event-&gt;getRequestType()) {
    // return immediately
    return;
}
</pre></div>
</div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Se você ainda não está familiarizado com o Dispatcher de Evento do Symfony2, leia
primeiro seção
<tt class="xref doc docutils literal"><span class="pre">Documentação</span> <span class="pre">do</span> <span class="pre">Compoenente</span> <span class="pre">Dispatcher</span> <span class="pre">de</span> <span class="pre">Evento</span></tt>
.</p>
</div>
<p>single: Evento; kernel.request</p>
</div>
<div class="section" id="evento-kernel-request">
<span id="kernel-core-request"></span><h4>Evento <tt class="docutils literal"><span class="pre">kernel.request</span></tt><a class="headerlink" href="#evento-kernel-request" title="Permalink to this headline">¶</a></h4>
<p><em>Classe do Evento</em>: <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/Event/GetResponseEvent.html" title="Symfony\Component\HttpKernel\Event\GetResponseEvent"><span class="pre">GetResponseEvent</span></a></tt></p>
<p>O objetivo deste evento é retornar um objeto <tt class="docutils literal"><span class="pre">Response</span></tt> ou variáveis de configuração
de um Controlador podem ser chamadas depois do evento. Qualquer listener pode returnar
um objeto <tt class="docutils literal"><span class="pre">Reponse</span></tt> através do métod <tt class="docutils literal"><span class="pre">setResponse()</span></tt> no evento. Neste caso, todos
os outros listeners não serão chamados.</p>
<p>Este evento é usado pelo <tt class="docutils literal"><span class="pre">FrameworkBundle</span></tt> para popular o <tt class="docutils literal"><span class="pre">_controller</span></tt> do atributo
do <tt class="docutils literal"><span class="pre">Request</span></tt>, através do
<tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Bundle/FrameworkBundle/EventListener/RouterListener.html" title="Symfony\Bundle\FrameworkBundle\EventListener\RouterListener"><span class="pre">RouterListener</span></a></tt>. RequestListener
usa um objeto  <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/Routing/RouterInterface.html" title="Symfony\Component\Routing\RouterInterface"><span class="pre">RouterInterface</span></a></tt> para combinar o
<tt class="docutils literal"><span class="pre">Request</span></tt> e determinar o nome do Controlador (armazenado no atributo <tt class="docutils literal"><span class="pre">_controller</span></tt>
do <tt class="docutils literal"><span class="pre">Request</span></tt>).</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Leia mais em <em class="xref std std-ref">evento kernel.request</em>.</p>
</div>
<p>single: Evento; kernel.controller</p>
</div>
<div class="section" id="evento-kernel-controller">
<h4>Evento <tt class="docutils literal"><span class="pre">kernel.controller</span></tt><a class="headerlink" href="#evento-kernel-controller" title="Permalink to this headline">¶</a></h4>
<p><em>Classe do Evento</em>: <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/Event/FilterControllerEvent.html" title="Symfony\Component\HttpKernel\Event\FilterControllerEvent"><span class="pre">FilterControllerEvent</span></a></tt></p>
<p>Este evento não é usado pelo <tt class="docutils literal"><span class="pre">FrameworkBundle</span></tt>, mas pode ser ponto de entrada usado
para modificar o controlador que será executado:</p>
<div class="highlight-python"><div class="highlight"><pre>use Symfony\Component\HttpKernel\Event\FilterControllerEvent;

public function onKernelController(FilterControllerEvent $event)
{
    $controller = $event-&gt;getController();
    // ...

    // o controlador pode ser trocado por qualquer código PHP válido
    $event-&gt;setController($controller);
}
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Leio mais em <em class="xref std std-ref">evento kernel.controller</em>.</p>
</div>
<p>single: Evento; kernel.view</p>
</div>
<div class="section" id="evento-kernel-view">
<h4>Evento <tt class="docutils literal"><span class="pre">kernel.view</span></tt><a class="headerlink" href="#evento-kernel-view" title="Permalink to this headline">¶</a></h4>
<p><em>Classe do Evento</em>: <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/Event/GetResponseForControllerResultEvent.html" title="Symfony\Component\HttpKernel\Event\GetResponseForControllerResultEvent"><span class="pre">GetResponseForControllerResultEvent</span></a></tt></p>
<p>Este evento não é usado pelo <tt class="docutils literal"><span class="pre">FrameworkBundle</span></tt>, mas pode ser usado para implementar
um sub-sistema de view. Este evento é chamado <em>apenas</em> se o Controlador <em>não</em> retornar
um objeto <tt class="docutils literal"><span class="pre">Response</span></tt>. A proposta deste evento é permitir que qualquer outro valor possa
ser convertido em um <tt class="docutils literal"><span class="pre">Response</span></tt>.</p>
<p>O valor retornado pelo Controlador é acessível através do método <tt class="docutils literal"><span class="pre">getControllerResult</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>use Symfony\Component\HttpKernel\Event\GetResponseForControllerResultEvent;
use Symfony\Component\HttpFoundation\Response;

public function onKernelView(GetResponseForControllerResultEvent $event)
{
    $val = $event-&gt;getControllerResult();
    $response = new Response();

    // ... uma maneria de customizar o Response a partir de um valor de retorno

    $event-&gt;setResponse($response);
}
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Leio mais no <em class="xref std std-ref">evento kernel.view</em>.</p>
</div>
<p>single: Evento; kernel.response</p>
</div>
<div class="section" id="evento-kernel-response">
<h4>Evento <tt class="docutils literal"><span class="pre">kernel.response</span></tt><a class="headerlink" href="#evento-kernel-response" title="Permalink to this headline">¶</a></h4>
<p><em>Classe do Evento</em>: <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/Event/FilterResponseEvent.html" title="Symfony\Component\HttpKernel\Event\FilterResponseEvent"><span class="pre">FilterResponseEvent</span></a></tt></p>
<p>A proposta deste evento é permitir outros sistemas de modificar ou substituir o objeto
<tt class="docutils literal"><span class="pre">Response</span></tt> depois de criado:</p>
<div class="highlight-python"><div class="highlight"><pre>public function onKernelResponse(FilterResponseEvent $event)
{
    $response = $event-&gt;getResponse();

    // ... modifique o objeto response
}
</pre></div>
</div>
<p>O``FrameworkBundle`` registra vários listeners:</p>
<ul class="simple">
<li><tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/EventListener/ProfilerListener.html" title="Symfony\Component\HttpKernel\EventListener\ProfilerListener"><span class="pre">ProfilerListener</span></a></tt>:
coleta dados para o pedido atual;</li>
<li><tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Bundle/WebProfilerBundle/EventListener/WebDebugToolbarListener.html" title="Symfony\Bundle\WebProfilerBundle\EventListener\WebDebugToolbarListener"><span class="pre">WebDebugToolbarListener</span></a></tt>:
injeta a Web Debug Toolbar;</li>
<li><tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/EventListener/ResponseListener.html" title="Symfony\Component\HttpKernel\EventListener\ResponseListener"><span class="pre">ResponseListener</span></a></tt>: fixes the
Responde <tt class="docutils literal"><span class="pre">Content-Type</span></tt> baseado no formato do pedido;</li>
<li><tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/EventListener/EsiListener.html" title="Symfony\Component\HttpKernel\EventListener\EsiListener"><span class="pre">EsiListener</span></a></tt>: adds a
Cabeçalho HTTP <tt class="docutils literal"><span class="pre">Surrogate-Control</span></tt> quando o Response precisa ser transformado para
tags ESI.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Leia mais no <em class="xref std std-ref">evento kernel.response</em>.</p>
</div>
<p>single: Evento; kernel.terminate</p>
</div>
<div class="section" id="evento-kernel-terminate">
<h4>Evento <tt class="docutils literal"><span class="pre">kernel.terminate</span></tt><a class="headerlink" href="#evento-kernel-terminate" title="Permalink to this headline">¶</a></h4>
<p>O objetivo deste evento é relizar tarefas mais &#8220;pesadas&#8221; depois que a resposta foi
entregue ao cliente.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Leia mais em <em class="xref std std-ref">evento kernel.terminate</em>.</p>
</div>
<p>single: Evento; kernel.exception</p>
</div>
<div class="section" id="evento-kernel-exception">
<span id="kernel-kernel-exception"></span><h4>Evento <tt class="docutils literal"><span class="pre">kernel.exception</span></tt><a class="headerlink" href="#evento-kernel-exception" title="Permalink to this headline">¶</a></h4>
<p><em>Classe de Evento</em>: <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/Event/GetResponseForExceptionEvent.html" title="Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent"><span class="pre">GetResponseForExceptionEvent</span></a></tt></p>
<p><tt class="docutils literal"><span class="pre">FrameworkBundle</span></tt> registra um
<tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/EventListener/ExceptionListener.html" title="Symfony\Component\HttpKernel\EventListener\ExceptionListener"><span class="pre">ExceptionListener</span></a></tt> que encaminha
o <tt class="docutils literal"><span class="pre">Request</span></tt> para um dado Controlador (o valor do parâmetro
<tt class="docutils literal"><span class="pre">exception_listener.controller</span></tt> &#8211; deve ser uma notação <tt class="docutils literal"><span class="pre">class::method</span></tt>).</p>
<p>Um listener deste evento pode criar e definir um objeto <tt class="docutils literal"><span class="pre">Response</span></tt>, criar e definir
um novo objeto <tt class="docutils literal"><span class="pre">Exception</span></tt>, ou fazer nada:</p>
<div class="highlight-python"><div class="highlight"><pre>use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent;
use Symfony\Component\HttpFoundation\Response;

public function onKernelException(GetResponseForExceptionEvent $event)
{
    $exception = $event-&gt;getException();
    $response = new Response();
    // configura o objeto Response baseado na exception capturada
    $event-&gt;setResponse($response);

    // você também pode definir uma nova Exception
    // $exception = new \Exception(&#39;Some special exception&#39;);
    // $event-&gt;setException($exception);
}
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Como o Symfony garante que o código do status do Response é como o mais adequado
dependendo da exceção, não vai funciona se definir o status na resposta. Se você
quiser substituir o código do status (você não deve fazer sem uma boa razão), defina
o <tt class="docutils literal"><span class="pre">X-Status-Code</span></tt> no cabeçalho:</p>
<div class="last highlight-python"><div class="highlight"><pre>return new Response(
    &#39;Error&#39;,
    404 // ignored,
    array(&#39;X-Status-Code&#39; =&gt; 200)
);
</pre></div>
</div>
</div>
<p>single: Dispatcher de Evento</p>
</div>
</div>
</div>
<div class="section" id="o-dispatcher-de-evento">
<h2>O Dispatcher de Evento<a class="headerlink" href="#o-dispatcher-de-evento" title="Permalink to this headline">¶</a></h2>
<p>O dispatcher de evento é um componente autônomo que é responsável por grande parte da lógica
subjacente e do fluxo por trás de um pedido Symfony. Para mais informações, veja a</p>
<blockquote>
<div><tt class="xref doc docutils literal"><span class="pre">Documentação</span> <span class="pre">do</span> <span class="pre">Componente</span> <span class="pre">Dispatcher</span> <span class="pre">de</span> <span class="pre">Evento</span></tt>.</div></blockquote>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Leia mais no <em class="xref std std-ref">evento kernel.exception</em>.</p>
</div>
<p>single: Profiler</p>
</div>
<div class="section" id="profiler">
<span id="internals-profiler"></span><h2>Profiler<a class="headerlink" href="#profiler" title="Permalink to this headline">¶</a></h2>
<p>Quando ativado, o profiler do Symfony2 coleta informações úteis sobre cada pedido feito
à sua aplicação e armazenadas para uma análise posterior. Utilize o profiler no
ambiente de desenvolvimento para ajudar a depurar seu código e melhorar o desempenho;
utilize-o em produção para problemas quando acontecerem.</p>
<p>Você raramente precisa lidar com o profiler diretamente, como o Symfony2 oferece ferramentas
como Web Debug Toolbar e o Web Profiler. Se você utilizar o Symfony2 Standard Edition,
o profiler, o web debug toolbar, e o web profiler estão configurados com configurações
razoáveis.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">O profiler coleta informações sobre todo os pedidos (pedidos simples, redirecionamentos,
exeçõec, pedidos Ajax, pedidos ESI; e para todos os métodos HTTP e todos formatos).
Isso significa que para uma única URL, você pode ter vários dados de perfis associados
(por pedido externo/resposta)</p>
</div>
<p>single: Profiler; Visualizando</p>
<div class="section" id="visualizando-os-dados-do-profiler">
<h3>Visualizando os dados do Profiler<a class="headerlink" href="#visualizando-os-dados-do-profiler" title="Permalink to this headline">¶</a></h3>
<div class="section" id="usando-a-web-debug-toolbar">
<h4>Usando a Web Debug Toolbar<a class="headerlink" href="#usando-a-web-debug-toolbar" title="Permalink to this headline">¶</a></h4>
<p>No ambiente de desenvolvimento, a web debug toolbar está dispinível na parte de inferior
de todas as páginas. Ela mostra um bom resumo do dados coletados e dá acesso instantâneo
a uma grande quantidade de informações úteis quando algo não funciona como o esperado.</p>
<p>Se o resumo oferecido pela Web Debug Toolbar não é suficiente, clique no link do token
(uma string feita de 13 caractéres randômicos) para acessar o Web Profiler.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Se o token não está clicável, isso significa que a rota do profiler não está
registrada (veja abaixo para obter informações de configuração)</p>
</div>
</div>
<div class="section" id="analisando-os-dados-com-o-web-profiler">
<h4>Analisando os dados com o Web Profiler<a class="headerlink" href="#analisando-os-dados-com-o-web-profiler" title="Permalink to this headline">¶</a></h4>
<p>O Web Profiler é uma ferramenta de visualização de dados que você pode usar no
desenvolvimento para depurar seu código e melhor o desempenho; mas pode também ser
usado para explorar problemas que ocorrem em produção. Ele expõe toda informação
coletada pelo profiler na interface web.</p>
<p>single: Profiler; Usando o serviço do profiler</p>
</div>
<div class="section" id="acessando-a-informacao-coletada">
<h4>Acessando a informação coletada<a class="headerlink" href="#acessando-a-informacao-coletada" title="Permalink to this headline">¶</a></h4>
<p>Você não precisa usar o visualizador padrão para acessar as informações coletadas. Mas
como você pode recuperar informações para um pedido específico? Quando o profiler armazena
os dados de um Request, também associa um token para ele; este token está disponível no
cabeçalho HTTP <tt class="docutils literal"><span class="pre">X-Debug-Token</span></tt> do Response:</p>
<div class="highlight-python"><div class="highlight"><pre>$profile = $container-&gt;get(&#39;profiler&#39;)-&gt;loadProfileFromResponse($response);

$profile = $container-&gt;get(&#39;profiler&#39;)-&gt;loadProfile($token);
</pre></div>
</div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Quando o profiler está ativado man não a web debug toolbar, ou quando você precisa
pegar o token para um pedido Aja, utilize uma ferramenta como o Firebug para pegar
o valor do cabeçalho HTTP <tt class="docutils literal"><span class="pre">X-Debug-Token</span></tt>.</p>
</div>
<p>Utilize o método <tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/Profiler/Profiler.html#method_find" title="Symfony\Component\HttpKernel\Profiler\Profiler::find()"><span class="pre">find()</span></a></tt>
para acessar os tokens baseados em alguns critérios:</p>
<div class="highlight-python"><div class="highlight"><pre>// pega os 10 últimos tokens
$tokens = $container-&gt;get(&#39;profiler&#39;)-&gt;find(&#39;&#39;, &#39;&#39;, 10);

// pegue os 10 últimos tokens para todas URLs que contenham /admin/
$tokens = $container-&gt;get(&#39;profiler&#39;)-&gt;find(&#39;&#39;, &#39;/admin/&#39;, 10);

// pegue os 10 últimos tokens para pedidos locais
$tokens = $container-&gt;get(&#39;profiler&#39;)-&gt;find(&#39;127.0.0.1&#39;, &#39;&#39;, 10);
</pre></div>
</div>
<p>Se você precisa manipular os dados coletados em uma máquina diferente da em que os dados
foram gerados, utilize os métodos
<tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/Profiler/Profiler.html#method_export" title="Symfony\Component\HttpKernel\Profiler\Profiler::export()"><span class="pre">export()</span></a></tt> e
<tt class="docutils literal"><a class="reference external" href="http://api.symfony.com/master/Symfony/Component/HttpKernel/Profiler/Profiler.html#method_import" title="Symfony\Component\HttpKernel\Profiler\Profiler::import()"><span class="pre">import()</span></a></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>// na máquina de produção
$profile = $container-&gt;get(&#39;profiler&#39;)-&gt;loadProfile($token);
$data = $profiler-&gt;export($profile);

// na máquina de desenvolvimento
$profiler-&gt;import($data);
</pre></div>
</div>
<p>single: Profiler; Visualizando</p>
</div>
<div class="section" id="configuracao">
<h4>Configuração<a class="headerlink" href="#configuracao" title="Permalink to this headline">¶</a></h4>
<p>A configuração padrão do Symfony2 vem com definições razoáveis para o profiler, a web
debug toolbar, e o web profiler. Aqui está um exemplo de configuração para o ambiente
de desenvolvimento:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># carrega o profiler</span>
<span class="l-Scalar-Plain">framework</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">profiler</span><span class="p-Indicator">:</span> <span class="p-Indicator">{</span> <span class="nv">only_exceptions</span><span class="p-Indicator">:</span> <span class="nv">false</span> <span class="p-Indicator">}</span>

<span class="c1"># ativa o web profiler</span>
<span class="l-Scalar-Plain">web_profiler</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">toolbar</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>
    <span class="l-Scalar-Plain">intercept_redirects</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>
<span class="nt">&lt;container</span> <span class="na">xmlns=</span><span class="s">&quot;http://symfony.com/schema/dic/services&quot;</span>
    <span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="na">xmlns:webprofiler=</span><span class="s">&quot;http://symfony.com/schema/dic/webprofiler&quot;</span>
    <span class="na">xmlns:framework=</span><span class="s">&quot;http://symfony.com/schema/dic/symfony&quot;</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd</span>
<span class="s">                        http://symfony.com/schema/dic/webprofiler http://symfony.com/schema/dic/webprofiler/webprofiler-1.0.xsd</span>
<span class="s">                        http://symfony.com/schema/dic/symfony http://symfony.com/schema/dic/symfony/symfony-1.0.xsd&quot;</span><span class="nt">&gt;</span>

    <span class="c">&lt;!-- load the profiler --&gt;</span>
    <span class="nt">&lt;framework:config&gt;</span>
        <span class="nt">&lt;framework:profiler</span> <span class="na">only-exceptions=</span><span class="s">&quot;false&quot;</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/framework:config&gt;</span>

    <span class="c">&lt;!-- enable the web profiler --&gt;</span>
    <span class="nt">&lt;webprofiler:config</span>
        <span class="na">toolbar=</span><span class="s">&quot;true&quot;</span>
        <span class="na">intercept-redirects=</span><span class="s">&quot;true&quot;</span>
        <span class="na">verbose=</span><span class="s">&quot;true&quot;</span>
    <span class="nt">/&gt;</span>
<span class="nt">&lt;/container&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="c1">// carrega o profiler</span>
<span class="nv">$container</span><span class="o">-&gt;</span><span class="na">loadFromExtension</span><span class="p">(</span><span class="s1">&#39;framework&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;profiler&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;only-exceptions&#39;</span> <span class="o">=&gt;</span> <span class="k">false</span><span class="p">),</span>
<span class="p">));</span>

<span class="c1">// ativa o web profiler</span>
<span class="nv">$container</span><span class="o">-&gt;</span><span class="na">loadFromExtension</span><span class="p">(</span><span class="s1">&#39;web_profiler&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;toolbar&#39;</span>             <span class="o">=&gt;</span> <span class="k">true</span><span class="p">,</span>
    <span class="s1">&#39;intercept-redirects&#39;</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">,</span>
<span class="p">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Quando <tt class="docutils literal"><span class="pre">only-execptions</span></tt> está definida como <tt class="docutils literal"><span class="pre">true</span></tt>, o profiler apenas coleta dados
quando uma exception é lançada pela aplicação.</p>
<p>Quando <tt class="docutils literal"><span class="pre">intercept-redirects</span></tt> é definido como <tt class="docutils literal"><span class="pre">true</span></tt>, o web profiler intercepta os
redirecionamentos e dá a você a oportunidade de ver os dados coletados antes de seguir
o redirecionamento.</p>
<p>Se você ativa o web profiler, você também precisa montar as rotas do profiler:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre>_profiler:
    resource: @WebProfilerBundle/Resources/config/routing/profiler.xml
    prefix:   /_profiler
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>
<span class="nt">&lt;routes</span> <span class="na">xmlns=</span><span class="s">&quot;http://symfony.com/schema/routing&quot;</span>
    <span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://symfony.com/schema/routing</span>
<span class="s">        http://symfony.com/schema/routing/routing-1.0.xsd&quot;</span><span class="nt">&gt;</span>

    <span class="nt">&lt;import</span>
        <span class="na">resource=</span><span class="s">&quot;@WebProfilerBundle/Resources/config/routing/profiler.xml&quot;</span>
        <span class="na">prefix=</span><span class="s">&quot;/_profiler&quot;</span>
    <span class="nt">/&gt;</span>
<span class="nt">&lt;/routes&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="nv">$collection</span><span class="o">-&gt;</span><span class="na">addCollection</span><span class="p">(</span>
    <span class="nv">$loader</span><span class="o">-&gt;</span><span class="na">import</span><span class="p">(</span>
        <span class="s2">&quot;@WebProfilerBundle/Resources/config/routing/profiler.xml&quot;</span>
    <span class="p">),</span>
    <span class="s1">&#39;/_profiler&#39;</span>
<span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Como o profiler adiciona alguma sobrecarga, você pode querer ativar apenas em algumas
circunstâncias no ambiente de desenvolvimento. O parâmetro <tt class="docutils literal"><span class="pre">only-exceptions</span></tt> limita
para 500 páginas, mas se quiser obter informações quando um IP do cliente vier de um
endereço específico, ou de uma parte limitada do site? Você pode usar um Profiler
Matcher, aprenda mais sobre ele no &#8220;<tt class="xref doc docutils literal"><span class="pre">/cookbook/profiler/matchers</span></tt>&#8221;.</p>
</div>
</div>
</div>
<div class="section" id="aprenda-mais-com-o-cookbook">
<h2>Aprenda mais com o Cookbook<a class="headerlink" href="#aprenda-mais-com-o-cookbook" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><tt class="xref doc docutils literal"><span class="pre">/cookbook/testing/profiling</span></tt></li>
<li><a class="reference internal" href="../cookbook/profiler/data_collector.html"><em>Como criar um Coletor de Dados personalizado</em></a></li>
<li><a class="reference internal" href="../cookbook/event_dispatcher/class_extension.html"><em>Como estender uma Classe sem usar Herança</em></a></li>
<li><a class="reference internal" href="../cookbook/event_dispatcher/method_behavior.html"><em>Como personalizar o Comportamento do Método sem o uso de Herança</em></a></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Bastidores</a><ul>
<li><a class="reference internal" href="#visao-geral">Visão Geral</a><ul>
<li><a class="reference internal" href="#componente-httpfoundation">Componente <tt class="docutils literal"><span class="pre">HttpFoundation</span></tt></a></li>
<li><a class="reference internal" href="#componente-httpkernel">Componente <tt class="docutils literal"><span class="pre">HttpKernel</span></tt></a></li>
<li><a class="reference internal" href="#o-bundle-frameworkbundle">O Bundle <tt class="docutils literal"><span class="pre">FrameworkBundle</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#kernel">Kernel</a><ul>
<li><a class="reference internal" href="#controladores">Controladores</a></li>
<li><a class="reference internal" href="#trantando-os-requests">Trantando os Requests</a></li>
<li><a class="reference internal" href="#requests-internos">Requests Internos</a></li>
<li><a class="reference internal" href="#eventos">Eventos</a><ul>
<li><a class="reference internal" href="#getrequesttype"><tt class="docutils literal"><span class="pre">getRequestType()</span></tt></a></li>
<li><a class="reference internal" href="#evento-kernel-request">Evento <tt class="docutils literal"><span class="pre">kernel.request</span></tt></a></li>
<li><a class="reference internal" href="#evento-kernel-controller">Evento <tt class="docutils literal"><span class="pre">kernel.controller</span></tt></a></li>
<li><a class="reference internal" href="#evento-kernel-view">Evento <tt class="docutils literal"><span class="pre">kernel.view</span></tt></a></li>
<li><a class="reference internal" href="#evento-kernel-response">Evento <tt class="docutils literal"><span class="pre">kernel.response</span></tt></a></li>
<li><a class="reference internal" href="#evento-kernel-terminate">Evento <tt class="docutils literal"><span class="pre">kernel.terminate</span></tt></a></li>
<li><a class="reference internal" href="#evento-kernel-exception">Evento <tt class="docutils literal"><span class="pre">kernel.exception</span></tt></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#o-dispatcher-de-evento">O Dispatcher de Evento</a></li>
<li><a class="reference internal" href="#profiler">Profiler</a><ul>
<li><a class="reference internal" href="#visualizando-os-dados-do-profiler">Visualizando os dados do Profiler</a><ul>
<li><a class="reference internal" href="#usando-a-web-debug-toolbar">Usando a Web Debug Toolbar</a></li>
<li><a class="reference internal" href="#analisando-os-dados-com-o-web-profiler">Analisando os dados com o Web Profiler</a></li>
<li><a class="reference internal" href="#acessando-a-informacao-coletada">Acessando a informação coletada</a></li>
<li><a class="reference internal" href="#configuracao">Configuração</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#aprenda-mais-com-o-cookbook">Aprenda mais com o Cookbook</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/book/internals.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li><a href="../index.html">Symfony2.4Docs 2.4 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Symfony Team + Symfony pt_BR Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>