<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Formulários &mdash; Symfony2.4Docs 2.4 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Symfony2.4Docs 2.4 documentation" href="../index.html" />
    <link rel="up" title="Livro" href="index.html" />
    <link rel="next" title="Segurança" href="security.html" />
    <link rel="prev" title="Validação" href="validation.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="security.html" title="Segurança"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="validation.html" title="Validação"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Symfony2.4Docs 2.4 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Livro</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="formularios">
<span id="index-0"></span><h1>Formulários<a class="headerlink" href="#formularios" title="Permalink to this headline">¶</a></h1>
<p>Lidar com formulários HTML é uma das mais comuns - e desafiadoras - tarefas para um
desenvolvedor web. O Symfony2 integra um componente de formulário que torna fácil a tarefa de lidar
com formulários. Neste capítulo, você vai construir um formulário complexo a partir do zero,
aprendendo as características mais importantes da biblioteca de formulários ao longo do caminho.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">O componente de formulário do Symfony é uma biblioteca independente que pode ser utilizada fora
de projetos Symfony2. Para mais informações, consulte o <a class="reference external" href="https://github.com/symfony/Form">Componente de Formulário do Symfony2</a>
no Github.</p>
</div>
<div class="section" id="criando-um-formulario-simples">
<span id="index-1"></span><h2>Criando um formulário simples<a class="headerlink" href="#criando-um-formulario-simples" title="Permalink to this headline">¶</a></h2>
<p>Suponha que você está construindo uma aplicação simples de lista de tarefas que precisará
exibir &#8220;tarefas&#8221;. Devido aos seus usuários terem que editar e criar tarefas, você precisará
construir um formulário. Mas, antes de começar, primeiro vamos focar na classe genérica <tt class="docutils literal"><span class="pre">Task</span></tt>
que representa e armazena os dados de uma única tarefa:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// src/Acme/TaskBundle/Entity/Task.php</span>
<span class="k">namespace</span> <span class="nx">Acme\TaskBundle\Entity</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Task</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="nv">$task</span><span class="p">;</span>

    <span class="k">protected</span> <span class="nv">$dueDate</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">getTask</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">task</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">setTask</span><span class="p">(</span><span class="nv">$task</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">task</span> <span class="o">=</span> <span class="nv">$task</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">getDueDate</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">dueDate</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">setDueDate</span><span class="p">(</span><span class="nx">\DateTime</span> <span class="nv">$dueDate</span> <span class="o">=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">dueDate</span> <span class="o">=</span> <span class="nv">$dueDate</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Se você está codificando junto com este exemplo, crie o <tt class="docutils literal"><span class="pre">AcmeTaskBundle</span></tt>
primeiro, executando o seguinte comando (e aceite todas as opções
padrão):</p>
<div class="last highlight-bash"><div class="highlight"><pre>php app/console generate:bundle --namespace<span class="o">=</span>Acme/TaskBundle
</pre></div>
</div>
</div>
<p>Essa classe é um &#8220;antigo objeto PHP simples&#8221;, porque, até agora, não tem nada
a ver com Symfony ou qualquer outra biblioteca. É simplesmente um objeto PHP normal
que, diretamente resolve um problema no interior da <em>sua</em> aplicação (ou seja, a necessidade de
representar uma tarefa na sua aplicação). Claro, até o final deste capítulo,
você será capaz de enviar dados para uma instância <tt class="docutils literal"><span class="pre">Task</span></tt> (através de um formulário HTML), validar
os seus dados, e persisti-los para o banco de dados.</p>
<div class="section" id="construindo-o-formulario">
<span id="index-2"></span><h3>Construindo o Formulário<a class="headerlink" href="#construindo-o-formulario" title="Permalink to this headline">¶</a></h3>
<p>Agora que você já criou a classe <tt class="docutils literal"><span class="pre">Task</span></tt>, o próximo passo é criar e renderizar
o formulário HTML real. No Symfony2, isto é feito através da construção de um objeto
de formulário e, em seguida, renderizando em um template. Por ora, tudo isso pode
ser feito dentro de um controlador:</p>
<div class="highlight-python"><div class="highlight"><pre>// src/Acme/TaskBundle/Controller/DefaultController.php
namespace Acme\TaskBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Acme\TaskBundle\Entity\Task;
use Symfony\Component\HttpFoundation\Request;

class DefaultController extends Controller
{
    public function newAction(Request $request)
    {
        // create a task and give it some dummy data for this example
        $task = new Task();
        $task-&gt;setTask(&#39;Write a blog post&#39;);
        $task-&gt;setDueDate(new \DateTime(&#39;tomorrow&#39;));

        $form = $this-&gt;createFormBuilder($task)
            -&gt;add(&#39;task&#39;, &#39;text&#39;)
            -&gt;add(&#39;dueDate&#39;, &#39;date&#39;)
            -&gt;getForm();

        return $this-&gt;render(&#39;AcmeTaskBundle:Default:new.html.twig&#39;, array(
            &#39;form&#39; =&gt; $form-&gt;createView(),
        ));
    }
}
</pre></div>
</div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Este exemplo mostra como construir o seu formulário diretamente no controlador.
Mais tarde, na seção &#8220;<a class="reference internal" href="#book-form-creating-form-classes"><em>Criando classes de formulário</em></a>&#8221;, você aprenderá
como construir o seu formulário em uma classe independente, que é o recomendado
pois torna o seu formulário reutilizável.</p>
</div>
<p>A criação de um formulário requer relativamente pouco código porque os objetos de formulário do Symfony2
são construídos com um &#8220;construtor de formulários&#8221;. A finalidade do construtor de formulários é permitir
que você escreva &#8220;receitas&#8221; simples de formulários, e ele fazer todo o trabalho pesado, de, realmente,
construir o formulário.</p>
<p>Neste exemplo, você acrescentou dois campos ao seu formulário - <tt class="docutils literal"><span class="pre">task</span></tt> e <tt class="docutils literal"><span class="pre">dueDate</span></tt> -
que correspondem as propriedades <tt class="docutils literal"><span class="pre">task</span></tt> e <tt class="docutils literal"><span class="pre">dueDate</span></tt> da classe <tt class="docutils literal"><span class="pre">Task</span></tt>.
Você também atribuiu a cada um deles um &#8220;type&#8221; (exemplo: <tt class="docutils literal"><span class="pre">text</span></tt>, <tt class="docutils literal"><span class="pre">date</span></tt>), que, entre
outras coisas, determina qual(ais) tag(s) HTML de formulário serão renderizadas para esse campo.</p>
<p>O Symfony2 vem com muitos tipos embutidos, que serão discutidos em breve
(veja <a class="reference internal" href="#book-forms-type-reference"><em>Tipos de campos integrados (Built-in)</em></a>).</p>
</div>
<div class="section" id="renderizando-o-formulario">
<span id="index-3"></span><h3>Renderizando o Formulário<a class="headerlink" href="#renderizando-o-formulario" title="Permalink to this headline">¶</a></h3>
<p>Agora que o formulário foi criado, o próximo passo é renderizá-lo. Isto é
feito passando um objeto &#8220;view&#8221; especial para o seu template (note o
<tt class="docutils literal"><span class="pre">$form-&gt;createView()</span></tt> no controlador acima) e usando um conjunto de funções helper
para o formulário:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>Twig</em><div class="highlight-html+jinja"><div class="highlight"><pre><span class="c">{# src/Acme/TaskBundle/Resources/views/Default/new.html.twig #}</span>

<span class="nt">&lt;form</span> <span class="na">action=</span><span class="s">&quot;</span><span class="cp">{{</span> <span class="nv">path</span><span class="o">(</span><span class="s1">&#39;task_new&#39;</span><span class="o">)</span> <span class="cp">}}</span><span class="s">&quot;</span> <span class="na">method=</span><span class="s">&quot;post&quot;</span> <span class="cp">{{</span> <span class="nv">form_enctype</span><span class="o">(</span><span class="nv">form</span><span class="o">)</span> <span class="cp">}}</span><span class="nt">&gt;</span>
    <span class="cp">{{</span> <span class="nv">form_widget</span><span class="o">(</span><span class="nv">form</span><span class="o">)</span> <span class="cp">}}</span>

    <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;submit&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-html+php"><div class="highlight"><pre><span class="c">&lt;!-- src/Acme/TaskBundle/Resources/views/Default/new.html.php --&gt;</span>

<span class="nt">&lt;form</span> <span class="na">action=</span><span class="s">&quot;</span><span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;router&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">generate</span><span class="p">(</span><span class="s1">&#39;task_new&#39;</span><span class="p">)</span> <span class="cp">?&gt;</span><span class="s">&quot;</span> <span class="na">method=</span><span class="s">&quot;post&quot;</span> <span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">enctype</span><span class="p">(</span><span class="nv">$form</span><span class="p">)</span> <span class="cp">?&gt;</span> <span class="nt">&gt;</span>
    <span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">widget</span><span class="p">(</span><span class="nv">$form</span><span class="p">)</span> <span class="cp">?&gt;</span>

    <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;submit&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<img alt="../_images/form-simple.png" class="align-center" src="../_images/form-simple.png" />
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Este exemplo assume que você criou uma rota chamada <tt class="docutils literal"><span class="pre">task_new</span></tt>
que aponta para o controlador <tt class="docutils literal"><span class="pre">AcmeTaskBundle:Default:new</span></tt> o qual
foi criado anteriormente.</p>
</div>
<p>É isso! Ao imprimir o <tt class="docutils literal"><span class="pre">form_widget(form)</span></tt>, cada campo do formulário é
renderizado, juntamente com uma label e uma mensagem de erro (se houver). Fácil
assim, embora não muito flexível (ainda). Normalmente, você desejará renderizar cada
campo do formulário individualmente, pois poderá controlar como será a aparência do formulário.
Você aprenderá como fazer isso na seção &#8220;<a class="reference internal" href="#form-rendering-template"><em>Renderizando um formulário em um Template</em></a>&#8221;.</p>
<p>Antes de prosseguirmos, observe como o campo input <tt class="docutils literal"><span class="pre">task</span></tt> renderizado tem o valor
da propriedade <tt class="docutils literal"><span class="pre">task</span></tt> do objeto <tt class="docutils literal"><span class="pre">$task</span></tt> (Ex. &#8220;Write a blog post&#8221;).
Este é o primeiro trabalho de um formulário: pegar os dados de um objeto e traduzi-lo
em um formato que seja adequado para ser renderizado em um formulário HTML.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">O sistema de formulários é inteligente o suficiente para acessar o valor da propriedade protegida
<tt class="docutils literal"><span class="pre">task</span></tt> através dos métodos <tt class="docutils literal"><span class="pre">getTask()</span></tt> e <tt class="docutils literal"><span class="pre">setTask()</span></tt> na classe <tt class="docutils literal"><span class="pre">Task</span></tt>. A menos que a
propriedade seja pública, ela <em>deve</em> ter um método &#8220;getter&#8221; e &#8220;setter&#8221; para que o componente de
formulário possa obter e definir os dados na propriedade. Para uma propriedade Boolean, você pode
usar um método &#8220;isser&#8221; (por exemplo, <tt class="docutils literal"><span class="pre">isPublished()</span></tt>) em vez de um getter
(Ex. <tt class="docutils literal"><span class="pre">getPublished()</span></tt>).</p>
</div>
</div>
<div class="section" id="manipulando-o-envio-de-formularios">
<span id="index-4"></span><h3>Manipulando o envio de formulários<a class="headerlink" href="#manipulando-o-envio-de-formularios" title="Permalink to this headline">¶</a></h3>
<p>O segundo trabalho de um formulário é traduzir os dados enviados pelo usuário de volta as
propriedades de um objeto. Para que isso aconteça, os dados enviados pelo
usuário devem ser vinculados (bound) ao formulário. Adicione as seguintes funcionalidades
no seu controlador:</p>
<div class="highlight-python"><div class="highlight"><pre>// ...

public function newAction(Request $request)
{
    // just setup a fresh $task object (remove the dummy data)
    $task = new Task();

    $form = $this-&gt;createFormBuilder($task)
        -&gt;add(&#39;task&#39;, &#39;text&#39;)
        -&gt;add(&#39;dueDate&#39;, &#39;date&#39;)
        -&gt;getForm();

    if ($request-&gt;isMethod(&#39;POST&#39;)) {
        $form-&gt;bind($request);

        if ($form-&gt;isValid()) {
            // perform some action, such as saving the task to the database

            return $this-&gt;redirect($this-&gt;generateUrl(&#39;task_success&#39;));
        }
    }

    // ...
}
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.1: </span>O método <tt class="docutils literal"><span class="pre">bind</span></tt> tornou-se mais flexível no Symfony 2.1. Ele aceita agora os
dados brutos do cliente (como antes) ou um objeto Request do Symfony. Ele é
preferido ao invés do método obsoleto <tt class="docutils literal"><span class="pre">bindRequest</span></tt>.</p>
</div>
<p>Agora, quando enviar o formulário, o controlador vincula (bind) ao formulário os dados enviados,
que traduz os dados de volta as propriedades <tt class="docutils literal"><span class="pre">task</span></tt> e <tt class="docutils literal"><span class="pre">dueDate</span></tt>
do objeto <tt class="docutils literal"><span class="pre">$task</span></tt>. Isso tudo acontece através do método <tt class="docutils literal"><span class="pre">bind()</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Assim que o <tt class="docutils literal"><span class="pre">bind()</span></tt> é chamado, os dados enviados são transferidos
imediatamente para o objeto implícito. Isso acontece independentemente dos
dados implícitos serem realmente válidos.</p>
</div>
<p>Este controlador segue um padrão comum para a manipulação de formulários, e possui três
caminhos possíveis:</p>
<ol class="arabic simple">
<li>Inicialmente quando se carrega a página em um navegador, o método de solicitação (request) é
<tt class="docutils literal"><span class="pre">GET</span></tt> e o formulário é simplesmente criado e renderizado;</li>
<li>Quando o usuário envia o formulário (Ex., o método é <tt class="docutils literal"><span class="pre">POST</span></tt>) mas os dados não são válidos
(a validação será discutida na próxima seção), o formulário é vinculado (bound) e
então processado, desta vez exibindo todos os erros de validação;</li>
<li>Quando o usuário envia o formulário com dados válidos, o formulário é vinculado (bound) e
você tem a oportunidade de executar algumas ações usando o objeto <tt class="docutils literal"><span class="pre">$task</span></tt>
(por exemplo, persisti-lo para o banco de dados) antes de redirecionar o usuário
para outra página (por exemplo, uma página de &#8220;obrigado&#8221; ou &#8220;sucesso&#8221;).</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Redirecionar o usuário após o envio bem sucedido do formulário impede que ele,
ao clicar em &#8220;atualizar&#8221;, reenvie os dados do formulário.</p>
</div>
</div>
</div>
<div class="section" id="validacao-do-formulario">
<span id="index-5"></span><h2>Validação do formulário<a class="headerlink" href="#validacao-do-formulario" title="Permalink to this headline">¶</a></h2>
<p>Na seção anterior, você aprendeu como um formulário pode ser enviado com dados
válidos ou inválidos. No Symfony2, a validação é aplicada ao objeto implícito
(Ex., <tt class="docutils literal"><span class="pre">Task</span></tt>). Em outras palavras, a questão não é se o &#8220;formulário&#8221; é
válido, mas se o objeto <tt class="docutils literal"><span class="pre">$task</span></tt> é válido após a aplicação dos dados enviados pelo
formulário. A chamada <tt class="docutils literal"><span class="pre">$form-&gt;isValid()</span></tt> é um atalho
que pergunta ao objeto <tt class="docutils literal"><span class="pre">$task</span></tt> se ele possui ou não dados válidos.</p>
<p>A validação é feita adicionando um conjunto de regras (chamadas <em>constraints</em>) à uma classe. Para
ver isso em ação, adicione <em>constraints</em> de validação para que o campo <tt class="docutils literal"><span class="pre">task</span></tt> não deve
ser vazio e o campo <tt class="docutils literal"><span class="pre">dueDate</span></tt> não deve ser vazio e deve ser um objeto DateTime
válido.</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># Acme/TaskBundle/Resources/config/validation.yml</span>
<span class="l-Scalar-Plain">Acme\TaskBundle\Entity\Task</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">properties</span><span class="p-Indicator">:</span>
        <span class="l-Scalar-Plain">task</span><span class="p-Indicator">:</span>
            <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">NotBlank</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">~</span>
        <span class="l-Scalar-Plain">dueDate</span><span class="p-Indicator">:</span>
            <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">NotBlank</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">~</span>
            <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">Type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">\DateTime</span>
</pre></div>
</div>
</li>
<li><em>Annotations</em><div class="highlight-php-annotations"><div class="highlight"><pre><span class="c1">// Acme/TaskBundle/Entity/Task.php</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Validator\Constraints</span> <span class="k">as</span> <span class="nx">Assert</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Task</span>
<span class="p">{</span>
    <span class="sd">/**</span>
<span class="sd">     * @Assert\NotBlank()</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="nv">$task</span><span class="p">;</span>

    <span class="sd">/**</span>
<span class="sd">     * @Assert\NotBlank()</span>
<span class="sd">     * @Assert\Type(&quot;\DateTime&quot;)</span>
<span class="sd">     */</span>
    <span class="k">protected</span> <span class="nv">$dueDate</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="c">&lt;!-- Acme/TaskBundle/Resources/config/validation.xml --&gt;</span>
<span class="nt">&lt;class</span> <span class="na">name=</span><span class="s">&quot;Acme\TaskBundle\Entity\Task&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;task&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;constraint</span> <span class="na">name=</span><span class="s">&quot;NotBlank&quot;</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;dueDate&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;constraint</span> <span class="na">name=</span><span class="s">&quot;NotBlank&quot;</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;constraint</span> <span class="na">name=</span><span class="s">&quot;Type&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;value&gt;</span>\DateTime<span class="nt">&lt;/value&gt;</span>
        <span class="nt">&lt;/constraint&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
<span class="nt">&lt;/class&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="c1">// Acme/TaskBundle/Entity/Task.php</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Validator\Mapping\ClassMetadata</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Validator\Constraints\NotBlank</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Validator\Constraints\Type</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Task</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">loadValidatorMetadata</span><span class="p">(</span><span class="nx">ClassMetadata</span> <span class="nv">$metadata</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$metadata</span><span class="o">-&gt;</span><span class="na">addPropertyConstraint</span><span class="p">(</span><span class="s1">&#39;task&#39;</span><span class="p">,</span> <span class="k">new</span> <span class="nx">NotBlank</span><span class="p">());</span>

        <span class="nv">$metadata</span><span class="o">-&gt;</span><span class="na">addPropertyConstraint</span><span class="p">(</span><span class="s1">&#39;dueDate&#39;</span><span class="p">,</span> <span class="k">new</span> <span class="nx">NotBlank</span><span class="p">());</span>
        <span class="nv">$metadata</span><span class="o">-&gt;</span><span class="na">addPropertyConstraint</span><span class="p">(</span><span class="s1">&#39;dueDate&#39;</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Type</span><span class="p">(</span><span class="s1">&#39;\DateTime&#39;</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>É isso! Se você reenviar o formulário com dados inválidos, verá os
erros correspondentes exibidos com o formulário.</p>
<div class="sidebar" id="book-forms-html5-validation-disable">
<p class="first sidebar-title">Validação HTML5</p>
<p>Com o HTML5, muitos navegadores podem, nativamente, impor certas <em>constraints</em> de validação
no lado do cliente. A validação mais comum é ativada renderizando
um atributo <tt class="docutils literal"><span class="pre">required</span></tt> em campos que são obrigatórios. Para navegadores que
suportam HTML5, isso irá resultar em uma mensagem nativa do navegador sendo exibida
se o usuário tentar enviar o formulário com o campo em branco.</p>
<p class="last">Os formulários gerados podem aproveitar ao máximo esta nova funcionalidade, adicionando
atributos HTML que disparam a validação. A validação ao lado do cliente,
entretanto, pode ser desativada ao adicionar o atributo <tt class="docutils literal"><span class="pre">novalidate</span></tt> na
tag <tt class="docutils literal"><span class="pre">form</span></tt> ou <tt class="docutils literal"><span class="pre">formnovalidate</span></tt> na tag submit. Isto é especialmente
útil quando você quiser testar suas <em>constraints</em> de validação ao lado do servidor,
mas estão sendo impedidas pelo seu navegador, por exemplo, ao enviar
campos em branco.</p>
</div>
<p>A validação é um recurso muito poderoso do Symfony2 e tem seu próprio
<a class="reference internal" href="validation.html"><em>capítulo dedicado</em></a>.</p>
<div class="section" id="grupos-de-validacao">
<span id="book-forms-validation-groups"></span><span id="index-6"></span><h3>Grupos de Validação<a class="headerlink" href="#grupos-de-validacao" title="Permalink to this headline">¶</a></h3>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Se você não estiver usando <a class="reference internal" href="validation.html#book-validation-validation-groups"><em>grupos de validação</em></a>,
então, você pode pular esta seção.</p>
</div>
<p>Se o seu objeto aproveita a <a class="reference internal" href="validation.html#book-validation-validation-groups"><em>grupos de validação</em></a>,
você precisa especificar qual(ais) grupo(s) de validação seu formulário deve usar:</p>
<div class="highlight-python"><div class="highlight"><pre>$form = $this-&gt;createFormBuilder($users, array(
    &#39;validation_groups&#39; =&gt; array(&#39;registration&#39;),
))-&gt;add(...)
;
</pre></div>
</div>
<p>Se você está criando <a class="reference internal" href="#book-form-creating-form-classes"><em>classes de formulário</em></a> (uma
boa prática), então você precisa adicionar o seguinte ao método
<tt class="docutils literal"><span class="pre">setDefaultOptions()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>use Symfony\Component\OptionsResolver\OptionsResolverInterface;

public function setDefaultOptions(OptionsResolverInterface $resolver)
{
    $resolver-&gt;setDefaults(array(
        &#39;validation_groups&#39; =&gt; array(&#39;registration&#39;)
    ));
}
</pre></div>
</div>
<p>Em ambos os casos, <em>apenas</em> o grupo de validação <tt class="docutils literal"><span class="pre">registration</span></tt> será
usado para validar o objeto implícito.</p>
</div>
<div class="section" id="grupos-com-base-nos-dados-submetidos">
<h3>Grupos com base nos dados submetidos<a class="headerlink" href="#grupos-com-base-nos-dados-submetidos" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.1: </span>A capacidade de especificar um callback ou Closure no <tt class="docutils literal"><span class="pre">validation_groups</span></tt>
é novo na versão 2.1</p>
</div>
<p>Se você precisar de alguma lógica avançada para determinar os grupos de validação (por exemplo,
com base nos dados submetidos), você pode definir a opção <tt class="docutils literal"><span class="pre">validation_groups</span></tt>
para um <tt class="docutils literal"><span class="pre">array</span> <span class="pre">callback</span></tt> ou uma <tt class="docutils literal"><span class="pre">Closure</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>use Symfony\Component\OptionsResolver\OptionsResolverInterface;

public function setDefaultOptions(OptionsResolverInterface $resolver)
{
    $resolver-&gt;setDefaults(array(
        &#39;validation_groups&#39; =&gt; array(&#39;Acme\\AcmeBundle\\Entity\\Client&#39;, &#39;determineValidationGroups&#39;),
    ));
}
</pre></div>
</div>
<p>Isso irá chamar o método estático <tt class="docutils literal"><span class="pre">determineValidationGroups()</span></tt> na
classe <tt class="docutils literal"><span class="pre">Client</span></tt> após o formulário ser vinculado (bound), mas antes da validação ser executada.
O objeto do formulário é passado como um argumento para esse método (veja o exemplo seguinte).
Você também pode definir toda a lógica inline usando uma Closure:</p>
<div class="highlight-python"><div class="highlight"><pre>use Symfony\Component\Form\FormInterface;
use Symfony\Component\OptionsResolver\OptionsResolverInterface;

public function setDefaultOptions(OptionsResolverInterface $resolver)
{
    $resolver-&gt;setDefaults(array(
        &#39;validation_groups&#39; =&gt; function(FormInterface $form) {
            $data = $form-&gt;getData();
            if (Entity\Client::TYPE_PERSON == $data-&gt;getType()) {
                return array(&#39;person&#39;)
            } else {
                return array(&#39;company&#39;);
            }
        },
    ));
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="tipos-de-campos-integrados-built-in">
<span id="book-forms-type-reference"></span><span id="index-7"></span><h2>Tipos de campos integrados (Built-in)<a class="headerlink" href="#tipos-de-campos-integrados-built-in" title="Permalink to this headline">¶</a></h2>
<p>O Symfony vem, por padrão, com um grande grupo de tipos de campos que cobrem todos os
os campos comuns de formulário e tipos de dados que você vai encontrar:</p>
<p>Você também pode criar os seus próprios tipos de campo personalizados. Este tópico é abordado
no artigo &#8220;<a class="reference internal" href="../cookbook/form/create_custom_field_type.html"><em>Como Criar um Tipo de Campo de Formulário Personalizado</em></a>&#8221; do cookbook.</p>
<div class="section" id="opcoes-dos-tipos-de-campos">
<span id="index-8"></span><h3>Opções dos tipos de campos<a class="headerlink" href="#opcoes-dos-tipos-de-campos" title="Permalink to this headline">¶</a></h3>
<p>Cada tipo de campo possui um número de opções que podem ser usadas ​​para configurá-lo.
Por exemplo, o campo <tt class="docutils literal"><span class="pre">dueDate</span></tt> é atualmente processado como 3 select
boxes. No entanto, o <tt class="xref doc docutils literal"><span class="pre">campo</span> <span class="pre">date</span></tt> pode ser
configurado para ser renderizado como uma caixa de texto simples (onde o usuário deve
digitar a data como uma string na caixa):</p>
<div class="highlight-python"><div class="highlight"><pre>-&gt;add(&#39;dueDate&#39;, &#39;date&#39;, array(&#39;widget&#39; =&gt; &#39;single_text&#39;))
</pre></div>
</div>
<img alt="../_images/form-simple2.png" class="align-center" src="../_images/form-simple2.png" />
<p>Cada tipo de campo tem um número de opções diferentes que podem ser passadas à ele.
Muitas delas são específicas para o tipo de campo e os detalhes podem ser encontrados
na documentação de cada tipo.</p>
<div class="sidebar">
<p class="first sidebar-title">A opção <tt class="docutils literal"><span class="pre">required</span></tt></p>
<p>A opção mais comum é a opção <tt class="docutils literal"><span class="pre">required</span></tt>, que pode ser aplicada à
qualquer campo. Por padrão, a opção <tt class="docutils literal"><span class="pre">required</span></tt> é definida como <tt class="docutils literal"><span class="pre">true</span></tt>, o que significa
que os navegadores prontos para o HTML5 aplicarão a validação ao lado do cliente se o campo
for deixado em branco. Se você não deseja esse comportamento, defina a opção <tt class="docutils literal"><span class="pre">required</span></tt>
em seu campo para <tt class="docutils literal"><span class="pre">false</span></tt> ou <a class="reference internal" href="#book-forms-html5-validation-disable"><em>desabilite a validação HTML5</em></a>.</p>
<p>Além disso, note que a configuração da opção <tt class="docutils literal"><span class="pre">required</span></tt> para <tt class="docutils literal"><span class="pre">true</span></tt> <strong>não</strong>
resultará em validação aplicada ao lado do servidor. Em outras palavras, se um
usuário enviar um valor em branco para o campo (ou usar um navegador antigo
ou web service, por exemplo), ela será aceita como um valor válido, a menos
que você utilize a constraint de validação do Symfony <tt class="docutils literal"><span class="pre">NotBlank</span></tt> ou <tt class="docutils literal"><span class="pre">NotNull</span></tt>.</p>
<p class="last">Em outras palavras, a opção <tt class="docutils literal"><span class="pre">required</span></tt> é &#8220;agradável&#8221;, mas a validação verdadeira
ao lado do servidor <em>sempre</em> deverá ser usada.</p>
</div>
</div>
</div>
<div class="section" id="adivinhando-o-tipo-do-campo">
<span id="book-forms-field-guessing"></span><span id="index-9"></span><h2>Adivinhando o tipo do campo<a class="headerlink" href="#adivinhando-o-tipo-do-campo" title="Permalink to this headline">¶</a></h2>
<p>Agora que você adicionou metadados de validação na classe <tt class="docutils literal"><span class="pre">Task</span></tt>, o Symfony
já sabe um pouco sobre os seus campos. Se você permitir, o Symfony pode &#8220;adivinhar&#8221;
o tipo do seu campo e configurá-lo para você. Neste exemplo, o Symfony pode
adivinhar a partir das regras de validação que o campo <tt class="docutils literal"><span class="pre">task</span></tt> é um campo <tt class="docutils literal"><span class="pre">texto</span></tt>
normal e o campo <tt class="docutils literal"><span class="pre">dueDate</span></tt> é um campo <tt class="docutils literal"><span class="pre">data</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>public function newAction()
{
    $task = new Task();

    $form = $this-&gt;createFormBuilder($task)
        -&gt;add(&#39;task&#39;)
        -&gt;add(&#39;dueDate&#39;, null, array(&#39;widget&#39; =&gt; &#39;single_text&#39;))
        -&gt;getForm();
}
</pre></div>
</div>
<p>A &#8220;adivinhação&#8221; é ativada quando você omitir o segundo argumento do método <tt class="docutils literal"><span class="pre">add()</span></tt>
(ou se você passar <tt class="docutils literal"><span class="pre">null</span></tt> para ele). Se você passar um array de opções como o
terceiro argumento (feito para o <tt class="docutils literal"><span class="pre">dueDate</span></tt> acima), estas opções são aplicadas ao
campo adivinhado.</p>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">Se o formulário usa um grupo de validação específico, o adivinhador do tipo de campo
ainda vai considerar <em>todas</em> as <em>constraints</em> de validação quando estiver adivinhando os seus
tipos de campos (incluindo as <em>constraints</em> que não fazem parte dos grupos de validação
sendo utilizados).</p>
</div>
<div class="section" id="adivinhando-as-opcoes-dos-tipos-de-campos">
<span id="index-10"></span><h3>Adivinhando as opções dos tipos de campos<a class="headerlink" href="#adivinhando-as-opcoes-dos-tipos-de-campos" title="Permalink to this headline">¶</a></h3>
<p>Além de adivinhar o &#8220;tipo&#8221; para um campo, o Symfony também pode tentar adivinhar
os valores corretos de uma série de opções do campo.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Quando essas opções são definidas, o campo será renderizado com atributos HTML especiais
que fornecem para a validação HTML5 ao lado do cliente. Entretanto, ele
não gera as <em>constraints</em> equivalentes ao lado do servidor (Ex. <tt class="docutils literal"><span class="pre">Assert\MaxLength</span></tt>).
E, embora você precisará adicionar manualmente a validação ao lado do servidor, essas
opções de tipo de campo podem, então, ser adivinhadas a partir dessa informação.</p>
</div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">required</span></tt>: A opção <tt class="docutils literal"><span class="pre">required</span></tt> pode ser adivinhada com base nas regras de
validação (ou seja, o campo é <tt class="docutils literal"><span class="pre">NotBlank</span></tt> ou <tt class="docutils literal"><span class="pre">NotNull</span></tt>) ou metadados do Doctrine
(ou seja, é o campo é <tt class="docutils literal"><span class="pre">nullable</span></tt>). Isto é muito útil, pois a sua validação ao lado
do cliente irá corresponder automaticamente as suas regras de validação.</li>
<li><tt class="docutils literal"><span class="pre">min_length</span></tt>: Se o campo é uma espécie de campo de texto, então, a opção <tt class="docutils literal"><span class="pre">min_length</span></tt>
pode ser adivinhada a partir das <em>constraints</em> de validação (se o <tt class="docutils literal"><span class="pre">MinLength</span></tt>
ou <tt class="docutils literal"><span class="pre">Min</span></tt> é usado) ou a partir dos metadados do Doctrine (através do tamanho do campo).</li>
<li><tt class="docutils literal"><span class="pre">max_length</span></tt>: Semelhante ao <tt class="docutils literal"><span class="pre">min_length</span></tt>, o tamanho máximo também pode
ser adivinhado.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Estas opções de campo são adivinhadas <em>apenas</em> se você estiver usando o Symfony para adivinhar
o tipo de campo (ou seja, omitir ou passar <tt class="docutils literal"><span class="pre">null</span></tt> como o segundo argumento para o <tt class="docutils literal"><span class="pre">add()</span></tt>).</p>
</div>
<p>Se você desejar modificar um dos valores adivinhados, você pode sobrescrevê-lo
passando a opção no array de opções do campo:</p>
<div class="highlight-python"><div class="highlight"><pre>-&gt;add(&#39;task&#39;, null, array(&#39;min_length&#39; =&gt; 4))
</pre></div>
</div>
</div>
</div>
<div class="section" id="renderizando-um-formulario-em-um-template">
<span id="form-rendering-template"></span><span id="index-11"></span><h2>Renderizando um formulário em um Template<a class="headerlink" href="#renderizando-um-formulario-em-um-template" title="Permalink to this headline">¶</a></h2>
<p>Até agora, você viu como um formulário inteiro pode ser renderizado com apenas uma linha
de código. Claro, você geralmente precisará de muito mais flexibilidade quando estiver renderizando:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>Twig</em><div class="highlight-html+jinja"><div class="highlight"><pre><span class="c">{# src/Acme/TaskBundle/Resources/views/Default/new.html.twig #}</span>

<span class="nt">&lt;form</span> <span class="na">action=</span><span class="s">&quot;</span><span class="cp">{{</span> <span class="nv">path</span><span class="o">(</span><span class="s1">&#39;task_new&#39;</span><span class="o">)</span> <span class="cp">}}</span><span class="s">&quot;</span> <span class="na">method=</span><span class="s">&quot;post&quot;</span> <span class="cp">{{</span> <span class="nv">form_enctype</span><span class="o">(</span><span class="nv">form</span><span class="o">)</span> <span class="cp">}}</span><span class="nt">&gt;</span>
    <span class="cp">{{</span> <span class="nv">form_errors</span><span class="o">(</span><span class="nv">form</span><span class="o">)</span> <span class="cp">}}</span>

    <span class="cp">{{</span> <span class="nv">form_row</span><span class="o">(</span><span class="nv">form.task</span><span class="o">)</span> <span class="cp">}}</span>
    <span class="cp">{{</span> <span class="nv">form_row</span><span class="o">(</span><span class="nv">form.dueDate</span><span class="o">)</span> <span class="cp">}}</span>

    <span class="cp">{{</span> <span class="nv">form_rest</span><span class="o">(</span><span class="nv">form</span><span class="o">)</span> <span class="cp">}}</span>

    <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;submit&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-html+php"><div class="highlight"><pre><span class="c">&lt;!-- // src/Acme/TaskBundle/Resources/views/Default/newAction.html.php --&gt;</span>

<span class="nt">&lt;form</span> <span class="na">action=</span><span class="s">&quot;</span><span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;router&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">generate</span><span class="p">(</span><span class="s1">&#39;task_new&#39;</span><span class="p">)</span> <span class="cp">?&gt;</span><span class="s">&quot;</span> <span class="na">method=</span><span class="s">&quot;post&quot;</span> <span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">enctype</span><span class="p">(</span><span class="nv">$form</span><span class="p">)</span> <span class="cp">?&gt;</span><span class="nt">&gt;</span>
    <span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">errors</span><span class="p">(</span><span class="nv">$form</span><span class="p">)</span> <span class="cp">?&gt;</span>

    <span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">row</span><span class="p">(</span><span class="nv">$form</span><span class="p">[</span><span class="s1">&#39;task&#39;</span><span class="p">])</span> <span class="cp">?&gt;</span>
    <span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">row</span><span class="p">(</span><span class="nv">$form</span><span class="p">[</span><span class="s1">&#39;dueDate&#39;</span><span class="p">])</span> <span class="cp">?&gt;</span>

    <span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">rest</span><span class="p">(</span><span class="nv">$form</span><span class="p">)</span> <span class="cp">?&gt;</span>

    <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;submit&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Vamos dar uma olhada em cada parte:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">form_enctype(form)</span></tt> - Se pelo menos um campo for um campo para upload de arquivo, ele irá
renderizar o <tt class="docutils literal"><span class="pre">enctype=&quot;multipart/form-data&quot;</span></tt> obrigatório;</li>
<li><tt class="docutils literal"><span class="pre">form_errors(form)</span></tt> - Renderiza quaisquer erros globais para todo o formulário
(erros específicos de campos são exibidos ao lado de cada campo);</li>
<li><tt class="docutils literal"><span class="pre">form_row(form.dueDate)</span></tt> - Renderiza a label, qualquer erro, e o widget
HTML do formulário para o campo informado (Ex. <tt class="docutils literal"><span class="pre">dueDate</span></tt>), por padrão, um
elemento <tt class="docutils literal"><span class="pre">div</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">form_rest(form)</span></tt> - Renderiza quaisquer campos que ainda não tenham sido renderizados.
Geralmente é uma boa idéia fazer uma chamada deste helper na parte inferior de
cada formulário (no caso de você ter esquecido algum campo ou não quer se preocupar
em renderizar manualmente os campos ocultos). Este helper também é útil para aproveitar
a <a class="reference internal" href="#forms-csrf"><em>Proteção CSRF</em></a> automática.</li>
</ul>
<p>A maioria do trabalho é feito pelo helper <tt class="docutils literal"><span class="pre">form_row</span></tt>, que renderiza
a label, os erros e widgets HTML do formulário para cada campo dentro de uma tag <tt class="docutils literal"><span class="pre">div</span></tt>
por padrão. Na seção <a class="reference internal" href="#form-theming"><em>Tematizando os formulários</em></a>, você aprenderá como a saída do <tt class="docutils literal"><span class="pre">form_row</span></tt>
pode ser personalizada em muitos níveis diferentes.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>Você pode acessar os dados atuais do seu formulário via <tt class="docutils literal"><span class="pre">form.vars.value</span></tt>:</p>
<div class="last configuration-block">
<ul class="simple">
<li><em>Twig</em><div class="highlight-jinja"><div class="highlight"><pre><span class="cp">{{</span> <span class="nv">form.vars.value.task</span> <span class="cp">}}</span><span class="x"></span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-html+php"><div class="highlight"><pre><span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">getTask</span><span class="p">()</span> <span class="cp">?&gt;</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="renderizando-cada-campo-manualmente">
<span id="index-12"></span><h3>Renderizando cada campo manualmente<a class="headerlink" href="#renderizando-cada-campo-manualmente" title="Permalink to this headline">¶</a></h3>
<p>O helper <tt class="docutils literal"><span class="pre">form_row</span></tt> é ótimo porque você pode renderizar rapidamente cada
campo de seu formulário (e também é possível personalizar a marcação utilizada para a &#8220;linha&#8221;
). Mas, como a vida nem sempre é tão simples, você também pode renderizar cada campo
inteiramente à mão. O produto final do que segue é o mesmo de quando você
usou o helper <tt class="docutils literal"><span class="pre">form_row</span></tt>:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>Twig</em><div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{{</span> <span class="nv">form_errors</span><span class="o">(</span><span class="nv">form</span><span class="o">)</span> <span class="cp">}}</span>

<span class="nt">&lt;div&gt;</span>
    <span class="cp">{{</span> <span class="nv">form_label</span><span class="o">(</span><span class="nv">form.task</span><span class="o">)</span> <span class="cp">}}</span>
    <span class="cp">{{</span> <span class="nv">form_errors</span><span class="o">(</span><span class="nv">form.task</span><span class="o">)</span> <span class="cp">}}</span>
    <span class="cp">{{</span> <span class="nv">form_widget</span><span class="o">(</span><span class="nv">form.task</span><span class="o">)</span> <span class="cp">}}</span>
<span class="nt">&lt;/div&gt;</span>

<span class="nt">&lt;div&gt;</span>
    <span class="cp">{{</span> <span class="nv">form_label</span><span class="o">(</span><span class="nv">form.dueDate</span><span class="o">)</span> <span class="cp">}}</span>
    <span class="cp">{{</span> <span class="nv">form_errors</span><span class="o">(</span><span class="nv">form.dueDate</span><span class="o">)</span> <span class="cp">}}</span>
    <span class="cp">{{</span> <span class="nv">form_widget</span><span class="o">(</span><span class="nv">form.dueDate</span><span class="o">)</span> <span class="cp">}}</span>
<span class="nt">&lt;/div&gt;</span>

<span class="cp">{{</span> <span class="nv">form_rest</span><span class="o">(</span><span class="nv">form</span><span class="o">)</span> <span class="cp">}}</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-html+php"><div class="highlight"><pre><span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">errors</span><span class="p">(</span><span class="nv">$form</span><span class="p">)</span> <span class="cp">?&gt;</span>

<span class="nt">&lt;div&gt;</span>
    <span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">label</span><span class="p">(</span><span class="nv">$form</span><span class="p">[</span><span class="s1">&#39;task&#39;</span><span class="p">])</span> <span class="cp">?&gt;</span>
    <span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">errors</span><span class="p">(</span><span class="nv">$form</span><span class="p">[</span><span class="s1">&#39;task&#39;</span><span class="p">])</span> <span class="cp">?&gt;</span>
    <span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">widget</span><span class="p">(</span><span class="nv">$form</span><span class="p">[</span><span class="s1">&#39;task&#39;</span><span class="p">])</span> <span class="cp">?&gt;</span>
<span class="nt">&lt;/div&gt;</span>

<span class="nt">&lt;div&gt;</span>
    <span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">label</span><span class="p">(</span><span class="nv">$form</span><span class="p">[</span><span class="s1">&#39;dueDate&#39;</span><span class="p">])</span> <span class="cp">?&gt;</span>
    <span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">errors</span><span class="p">(</span><span class="nv">$form</span><span class="p">[</span><span class="s1">&#39;dueDate&#39;</span><span class="p">])</span> <span class="cp">?&gt;</span>
    <span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">widget</span><span class="p">(</span><span class="nv">$form</span><span class="p">[</span><span class="s1">&#39;dueDate&#39;</span><span class="p">])</span> <span class="cp">?&gt;</span>
<span class="nt">&lt;/div&gt;</span>

<span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">rest</span><span class="p">(</span><span class="nv">$form</span><span class="p">)</span> <span class="cp">?&gt;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Se a label auto-gerada para um campo não estiver correta, você pode especificá-la
explicitamente:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>Twig</em><div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{{</span> <span class="nv">form_label</span><span class="o">(</span><span class="nv">form.task</span><span class="o">,</span> <span class="s1">&#39;Task Description&#39;</span><span class="o">)</span> <span class="cp">}}</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-html+php"><div class="highlight"><pre><span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">label</span><span class="p">(</span><span class="nv">$form</span><span class="p">[</span><span class="s1">&#39;task&#39;</span><span class="p">],</span> <span class="s1">&#39;Task Description&#39;</span><span class="p">)</span> <span class="cp">?&gt;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Finalmente, alguns tipos de campos tem opções de renderização adicionais que podem ser passadas
para o widget. Estas opções estão documentadas com cada tipo, mas uma opção em comum
é o <tt class="docutils literal"><span class="pre">attr</span></tt>, que permite modificar atributos no elemento do formulário.
O seguinte código adiciona a classe <tt class="docutils literal"><span class="pre">task_field</span></tt> para o campo texto de entrada
renderizado:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>Twig</em><div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{{</span> <span class="nv">form_widget</span><span class="o">(</span><span class="nv">form.task</span><span class="o">,</span> <span class="o">{</span> <span class="s1">&#39;attr&#39;</span><span class="o">:</span> <span class="o">{</span><span class="s1">&#39;class&#39;</span><span class="o">:</span> <span class="s1">&#39;task_field&#39;</span><span class="o">}</span> <span class="o">})</span> <span class="cp">}}</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-html+php"><div class="highlight"><pre><span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">widget</span><span class="p">(</span><span class="nv">$form</span><span class="p">[</span><span class="s1">&#39;task&#39;</span><span class="p">],</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;attr&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;class&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;task_field&#39;</span><span class="p">),</span>
<span class="p">))</span> <span class="cp">?&gt;</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="referencia-de-funcoes-dos-templates-twig">
<h3>Referência de funções dos templates Twig<a class="headerlink" href="#referencia-de-funcoes-dos-templates-twig" title="Permalink to this headline">¶</a></h3>
<p>Se você está usando o Twig, uma referência completa das funções de renderização do formulário
está disponível no <tt class="xref doc docutils literal"><span class="pre">manual</span> <span class="pre">de</span> <span class="pre">referência</span></tt>.
Leia ele para saber tudo sobre os helpers disponíveis e as opções
que podem ser usadas ​​com cada um.</p>
</div>
</div>
<div class="section" id="criando-classes-de-formulario">
<span id="book-form-creating-form-classes"></span><span id="index-13"></span><h2>Criando classes de formulário<a class="headerlink" href="#criando-classes-de-formulario" title="Permalink to this headline">¶</a></h2>
<p>Como você viu, um formulário pode ser criado e usado diretamente em um controlador.
No entanto, uma prática melhor é construir o formulário separadamente, em uma classe PHP independente,
que poderá, então, ser reutilizada em qualquer lugar na sua aplicação. Crie uma nova classe
que vai abrigar a lógica da construção do formulário de tarefas:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// src/Acme/TaskBundle/Form/Type/TaskType.php</span>

<span class="k">namespace</span> <span class="nx">Acme\TaskBundle\Form\Type</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Symfony\Component\Form\AbstractType</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Form\FormBuilderInterface</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">TaskType</span> <span class="k">extends</span> <span class="nx">AbstractType</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">buildForm</span><span class="p">(</span><span class="nx">FormBuilderInterface</span> <span class="nv">$builder</span><span class="p">,</span> <span class="k">array</span> <span class="nv">$options</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$builder</span><span class="o">-&gt;</span><span class="na">add</span><span class="p">(</span><span class="s1">&#39;task&#39;</span><span class="p">);</span>
        <span class="nv">$builder</span><span class="o">-&gt;</span><span class="na">add</span><span class="p">(</span><span class="s1">&#39;dueDate&#39;</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;widget&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;single_text&#39;</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">getName</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s1">&#39;task&#39;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Esta nova classe contém todas as orientações necessárias para criar o formulário de tarefas
(Note que o método <tt class="docutils literal"><span class="pre">getName()</span></tt> deve retornar um identificador exclusivo para esse
&#8220;tipo&#8221; do formulário). Ele pode ser usado para construir rapidamente um objeto de formulário no controlador:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// src/Acme/TaskBundle/Controller/DefaultController.php</span>

<span class="c1">// add this new use statement at the top of the class</span>
<span class="k">use</span> <span class="nx">Acme\TaskBundle\Form\Type\TaskType</span><span class="p">;</span>

<span class="k">public</span> <span class="k">function</span> <span class="nf">newAction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$task</span> <span class="o">=</span> <span class="c1">// ...</span>
    <span class="nv">$form</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">createForm</span><span class="p">(</span><span class="k">new</span> <span class="nx">TaskType</span><span class="p">(),</span> <span class="nv">$task</span><span class="p">);</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Colocando a lógica do formulário em sua própria classe significa que o formulário pode ser facilmente
reutilizado em outros lugares no seu projeto. Esta é a melhor forma de criar formulários, mas,
a decisão final depende de você.</p>
<div class="sidebar" id="book-forms-data-class">
<p class="first sidebar-title">Setando o <tt class="docutils literal"><span class="pre">data_class</span></tt></p>
<p>Todo formulário precisa saber o nome da classe que contém os dados implícitos
(Ex. <tt class="docutils literal"><span class="pre">Acme\TaskBundle\Entity\Task</span></tt>). Normalmente, ele é apenas adivinhado
com base no objeto passado no segundo argumento para o <tt class="docutils literal"><span class="pre">createForm</span></tt>
(Ex. <tt class="docutils literal"><span class="pre">$task</span></tt>). Mais tarde, quando você iniciar nos formulários embutidos, isto
não será suficiente. Então, embora nem sempre necessário, é geralmente uma
boa idéia especificar explicitamente a opção <tt class="docutils literal"><span class="pre">data_class</span></tt> adicionando
o seguinte à sua classe type de formulário:</p>
<div class="last highlight-python"><div class="highlight"><pre>use Symfony\Component\OptionsResolver\OptionsResolverInterface;

public function setDefaultOptions(OptionsResolverInterface $resolver)
{
    $resolver-&gt;setDefaults(array(
        &#39;data_class&#39; =&gt; &#39;Acme\TaskBundle\Entity\Task&#39;,
    ));
}
</pre></div>
</div>
</div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>Ao mapear formulários para objetos, todos os campos são mapeados. Qualquer
campo do formulário que não existe no objeto mapeado irá fazer com que uma
exceção seja gerada.</p>
<p>Nos casos em que você precisa de campos extras na formulário (por exemplo: um
checkbox &#8220;você concorda com os termos&#8221;) que não será mapeado para o objeto implícito,
você precisa definir a opção property_path como <tt class="docutils literal"><span class="pre">false</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>use Symfony\Component\Form\FormBuilderInterface;

public function buildForm(FormBuilderInterface $builder, array $options)
{
    $builder-&gt;add(&#39;task&#39;);
    $builder-&gt;add(&#39;dueDate&#39;, null, array(&#39;property_path&#39; =&gt; false));
}
</pre></div>
</div>
<p>Além disso, se houver quaiquer campos do formulário que não estão incluídos nos
dados submetidos, esses campos serão definidos explicitamente como <tt class="docutils literal"><span class="pre">null</span></tt>.</p>
<p>Os dados do campo podem ser acessados em um controlador com:</p>
<div class="last highlight-python"><div class="highlight"><pre>$form-&gt;get(&#39;dueDate&#39;)-&gt;getData();
</pre></div>
</div>
</div>
</div>
<div class="section" id="formularios-e-o-doctrine">
<span id="index-14"></span><h2>Formulários e o Doctrine<a class="headerlink" href="#formularios-e-o-doctrine" title="Permalink to this headline">¶</a></h2>
<p>O objetivo de um formulário é traduzir os dados de um objeto (Ex. <tt class="docutils literal"><span class="pre">Task</span></tt>) para um
formulário HTML e, em seguida, traduzir os dados enviados pelo usuário de volta ao objeto original.
Como tal, o tópico da persistência do objeto <tt class="docutils literal"><span class="pre">Task</span></tt> no banco de dados é totalmente
não relacionado ao tópico de formulários. Mas, se você configurou a classe <tt class="docutils literal"><span class="pre">Task</span></tt>
para ser persistida através do Doctrine (ou seja, você adicionou
<a class="reference internal" href="doctrine.html#book-doctrine-adding-mapping"><em>metadados de mapeamento</em></a> à ele), então, a persistência
após a submissão do formulário pode ser feita quando o formulário é válido:</p>
<div class="highlight-python"><div class="highlight"><pre>if ($form-&gt;isValid()) {
    $em = $this-&gt;getDoctrine()-&gt;getManager();
    $em-&gt;persist($task);
    $em-&gt;flush();

    return $this-&gt;redirect($this-&gt;generateUrl(&#39;task_success&#39;));
}
</pre></div>
</div>
<p>Se, por algum motivo, você não tem acesso ao seu objeto <tt class="docutils literal"><span class="pre">$task</span></tt> original,
você pode buscá-lo a partir do formulário:</p>
<div class="highlight-python"><div class="highlight"><pre>$task = $form-&gt;getData();
</pre></div>
</div>
<p>Para mais informações, consulte o <a class="reference internal" href="doctrine.html"><em>capítulo Doctrine ORM</em></a>.</p>
<p>A chave para entender é que, quando o formulário é vinculado (bound), os dados submetidos
são transferidos imediatamente para o objeto implícito. Se você quiser
persistir esses dados, basta persistir o objeto em si (que já
contém os dados submetidos).</p>
</div>
<div class="section" id="formularios-embutidos">
<span id="index-15"></span><h2>Formulários embutidos<a class="headerlink" href="#formularios-embutidos" title="Permalink to this headline">¶</a></h2>
<p>Muitas vezes, você desejará criar um formulário que vai incluir campos de vários objetos
diferentes. Por exemplo, um formulário de inscrição pode conter dados que pertencem a
um objeto <tt class="docutils literal"><span class="pre">User</span></tt>, bem como, muitos objetos <tt class="docutils literal"><span class="pre">Address</span></tt>. Felizmente, isto
é fácil e natural com o componente de formulário.</p>
<div class="section" id="embutindo-um-unico-objeto">
<h3>Embutindo um único objeto<a class="headerlink" href="#embutindo-um-unico-objeto" title="Permalink to this headline">¶</a></h3>
<p>Suponha que cada <tt class="docutils literal"><span class="pre">Task</span></tt> pertence a um simples objeto <tt class="docutils literal"><span class="pre">Category</span></tt>. Inicie,
é claro, criando o objeto <tt class="docutils literal"><span class="pre">Category</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>// src/Acme/TaskBundle/Entity/Category.php
namespace Acme\TaskBundle\Entity;

use Symfony\Component\Validator\Constraints as Assert;

class Category
{
    /**
     * @Assert\NotBlank()
     */
    public $name;
}
</pre></div>
</div>
<p>Em seguida, adicione uma nova propriedade <tt class="docutils literal"><span class="pre">category</span></tt> na classe <tt class="docutils literal"><span class="pre">Task</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>// ...

class Task
{
    // ...

    /**
     * @Assert\Type(type=&quot;Acme\TaskBundle\Entity\Category&quot;)
     */
    protected $category;

    // ...

    public function getCategory()
    {
        return $this-&gt;category;
    }

    public function setCategory(Category $category = null)
    {
        $this-&gt;category = $category;
    }
}
</pre></div>
</div>
<p>Agora que a sua aplicação foi atualizada para refletir as novas exigências,
crie uma classe de formulário para que o objeto <tt class="docutils literal"><span class="pre">Category</span></tt> possa ser modificado pelo usuário:</p>
<div class="highlight-python"><div class="highlight"><pre>// src/Acme/TaskBundle/Form/Type/CategoryType.php
namespace Acme\TaskBundle\Form\Type;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolverInterface;

class CategoryType extends AbstractType
{
    public function buildForm(FormBuilderInterface $builder, array $options)
    {
        $builder-&gt;add(&#39;name&#39;);
    }

    public function setDefaultOptions(OptionsResolverInterface $resolver)
    {
        $resolver-&gt;setDefaults(array(
            &#39;data_class&#39; =&gt; &#39;Acme\TaskBundle\Entity\Category&#39;,
        ));
    }

    public function getName()
    {
        return &#39;category&#39;;
    }
}
</pre></div>
</div>
<p>O objetivo final é permitir que a <tt class="docutils literal"><span class="pre">Category</span></tt> de uma <tt class="docutils literal"><span class="pre">Task</span></tt> possa ser modificada direitamente
dentro do próprio formulário da tarefa. Para fazer isso, adicione um campo <tt class="docutils literal"><span class="pre">category</span></tt>
ao objeto <tt class="docutils literal"><span class="pre">TaskType</span></tt> cujo tipo é uma instância da nova classe
<tt class="docutils literal"><span class="pre">CategoryType</span></tt>:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">use</span> <span class="nx">Symfony\Component\Form\FormBuilderInterface</span><span class="p">;</span>

<span class="k">public</span> <span class="k">function</span> <span class="nf">buildForm</span><span class="p">(</span><span class="nx">FormBuilderInterface</span> <span class="nv">$builder</span><span class="p">,</span> <span class="k">array</span> <span class="nv">$options</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="nv">$builder</span><span class="o">-&gt;</span><span class="na">add</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">,</span> <span class="k">new</span> <span class="nx">CategoryType</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Os campos do <tt class="docutils literal"><span class="pre">CategoryType</span></tt> podem agora ser renderizados juntamente com os campos da
classe <tt class="docutils literal"><span class="pre">TaskType</span></tt>. Para ativar a validação no CategoryType, adicione
a opção <tt class="docutils literal"><span class="pre">cascade_validation</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>public function setDefaultOptions(OptionsResolverInterface $resolver)
{
    $resolver-&gt;setDefaults(array(
        &#39;data_class&#39; =&gt; &#39;Acme\TaskBundle\Entity\Category&#39;,
        &#39;cascade_validation&#39; =&gt; true,
    ));
}
</pre></div>
</div>
<p>Renderize os campos <tt class="docutils literal"><span class="pre">Category</span></tt> da mesma forma
que os campos originais da <tt class="docutils literal"><span class="pre">Task</span></tt>:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>Twig</em><div class="highlight-html+jinja"><div class="highlight"><pre><span class="c">{# ... #}</span>

<span class="nt">&lt;h3&gt;</span>Category<span class="nt">&lt;/h3&gt;</span>
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;category&quot;</span><span class="nt">&gt;</span>
    <span class="cp">{{</span> <span class="nv">form_row</span><span class="o">(</span><span class="nv">form.category.name</span><span class="o">)</span> <span class="cp">}}</span>
<span class="nt">&lt;/div&gt;</span>

<span class="cp">{{</span> <span class="nv">form_rest</span><span class="o">(</span><span class="nv">form</span><span class="o">)</span> <span class="cp">}}</span>
<span class="c">{# ... #}</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-html+php"><div class="highlight"><pre><span class="c">&lt;!-- ... --&gt;</span>

<span class="nt">&lt;h3&gt;</span>Category<span class="nt">&lt;/h3&gt;</span>
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;category&quot;</span><span class="nt">&gt;</span>
    <span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">row</span><span class="p">(</span><span class="nv">$form</span><span class="p">[</span><span class="s1">&#39;category&#39;</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">])</span> <span class="cp">?&gt;</span>
<span class="nt">&lt;/div&gt;</span>

<span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">rest</span><span class="p">(</span><span class="nv">$form</span><span class="p">)</span> <span class="cp">?&gt;</span>
<span class="c">&lt;!-- ... --&gt;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Quando o usuário enviar o formulário, os dados submetidos para os campos <tt class="docutils literal"><span class="pre">Category</span></tt>
são usados ​​para construir uma instância de <tt class="docutils literal"><span class="pre">Category</span></tt>, que é então definida
no campo <tt class="docutils literal"><span class="pre">Category</span></tt> da instância <tt class="docutils literal"><span class="pre">Task</span></tt>.</p>
<p>A instância <tt class="docutils literal"><span class="pre">Category</span></tt> é acessível naturalmente via <tt class="docutils literal"><span class="pre">$task-&gt;getCategory()</span></tt>
e pode ser persistida no banco de dados ou usada como você precisar.</p>
</div>
<div class="section" id="embutindo-uma-colecao-de-formularios">
<h3>Embutindo uma coleção de formulários<a class="headerlink" href="#embutindo-uma-colecao-de-formularios" title="Permalink to this headline">¶</a></h3>
<p>Você também pode embutir uma coleção de formulários em um formulário (imagine um formulário
<tt class="docutils literal"><span class="pre">Category</span></tt> com muitos sub-formulários <tt class="docutils literal"><span class="pre">Product</span></tt>). Isto é feito usando o tipo de
campo <tt class="docutils literal"><span class="pre">collection</span></tt>.</p>
<p>Para mais informações consulte no &#8220;<a class="reference internal" href="../cookbook/form/form_collections.html"><em>Como embutir uma Coleção de Formulários</em></a>&#8221;
e na <em class="xref std std-ref">collection</em> referência dos tipos de campo.</p>
</div>
</div>
<div class="section" id="tematizando-os-formularios">
<span id="form-theming"></span><span id="index-16"></span><h2>Tematizando os formulários<a class="headerlink" href="#tematizando-os-formularios" title="Permalink to this headline">¶</a></h2>
<p>Cada parte de como um formulário é renderizado pode ser personalizada. Você está livre para mudar
como cada &#8220;linha&#8221; do formulário é renderizada, alterar a marcação usada para renderizar os erros, ou
até mesmo, personalizar como uma tag <a href="#id1"><span class="problematic" id="id2">``</span></a>textarea` deve ser renderizada. Nada está fora dos limites,
e é possível utilizar diferentes personalizações ​​em diferentes lugares.</p>
<p>O Symfony utiliza templates para renderizar todas e cada uma das partes de um formulário, tais como
tags <tt class="docutils literal"><span class="pre">label</span></tt>, tags <tt class="docutils literal"><span class="pre">input</span></tt>, mensagens de erro e tudo mais.</p>
<p>No Twig, cada &#8220;fragmento&#8221; do formulário é representado por um bloco Twig. Para personalizar
qualquer parte de como um formulário é renderizado, você só precisa substituir o bloco apropriado.</p>
<p>No PHP, cada &#8220;fragmento&#8221; do formulário é renderizado por um arquivo de template individual.
Para personalizar qualquer parte de como um formulário é renderizado, você só precisa sobrescrever o
template já existente, criando um novo.</p>
<p>Para entender como isso funciona, vamos personalizar o fragmento <tt class="docutils literal"><span class="pre">form_row</span></tt> e
adicionar um atributo class para o elemento <tt class="docutils literal"><span class="pre">div</span></tt> que envolve cada linha. Para
fazer isso, crie um novo arquivo template que irá armazenar a marcação nova:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>Twig</em><div class="highlight-html+jinja"><div class="highlight"><pre><span class="c">{# src/Acme/TaskBundle/Resources/views/Form/fields.html.twig #}</span>

<span class="cp">{%</span> <span class="k">block</span> <span class="nv">field_row</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">spaceless</span> <span class="cp">%}</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;form_row&quot;</span><span class="nt">&gt;</span>
        <span class="cp">{{</span> <span class="nv">form_label</span><span class="o">(</span><span class="nv">form</span><span class="o">)</span> <span class="cp">}}</span>
        <span class="cp">{{</span> <span class="nv">form_errors</span><span class="o">(</span><span class="nv">form</span><span class="o">)</span> <span class="cp">}}</span>
        <span class="cp">{{</span> <span class="nv">form_widget</span><span class="o">(</span><span class="nv">form</span><span class="o">)</span> <span class="cp">}}</span>
    <span class="nt">&lt;/div&gt;</span>
<span class="cp">{%</span> <span class="k">endspaceless</span> <span class="cp">%}</span>
<span class="cp">{%</span> <span class="k">endblock</span> <span class="nv">field_row</span> <span class="cp">%}</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-html+php"><div class="highlight"><pre><span class="c">&lt;!-- src/Acme/TaskBundle/Resources/views/Form/field_row.html.php --&gt;</span>

<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;form_row&quot;</span><span class="nt">&gt;</span>
    <span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">label</span><span class="p">(</span><span class="nv">$form</span><span class="p">,</span> <span class="nv">$label</span><span class="p">)</span> <span class="cp">?&gt;</span>
    <span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">errors</span><span class="p">(</span><span class="nv">$form</span><span class="p">)</span> <span class="cp">?&gt;</span>
    <span class="cp">&lt;?php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;form&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">widget</span><span class="p">(</span><span class="nv">$form</span><span class="p">,</span> <span class="nv">$parameters</span><span class="p">)</span> <span class="cp">?&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>O fragmento <tt class="docutils literal"><span class="pre">field_row</span></tt> do formulário é utilizado para renderizar a maioria dos campos através da
da função <tt class="docutils literal"><span class="pre">form_row</span></tt>. Para dizer ao componente de formulário para utilizar o seu novo fragmento
<tt class="docutils literal"><span class="pre">field_row</span></tt> definido acima, adicione o seguinte no topo do template que
renderiza o formulário:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>Twig</em><div class="highlight-html+jinja"><div class="highlight"><pre>{# src/Acme/TaskBundle/Resources/views/Default/new.html.twig #}

{% form_theme form &#39;AcmeTaskBundle:Form:fields.html.twig&#39; %}

&lt;form ...&gt;
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-html+php"><div class="highlight"><pre>&lt;!-- src/Acme/TaskBundle/Resources/views/Default/new.html.php --&gt;

&lt;?php $view[&#39;form&#39;]-&gt;setTheme($form, array(&#39;AcmeTaskBundle:Form&#39;)) ?&gt;

&lt;form ...&gt;
</pre></div>
</div>
</li>
</ul>
</div>
<p>A tag <tt class="docutils literal"><span class="pre">form_theme</span></tt> (no Twig) &#8220;importa&#8221; os fragmentos definidos no
template informado e utiliza-os quando renderiza o formulário. Em outras palavras,
quando a função <tt class="docutils literal"><span class="pre">form_row</span></tt> é chamada mais tarde neste template, ela usará o bloco
<tt class="docutils literal"><span class="pre">field_row</span></tt> de seu tema personalizado (ao invés do bloco padrão <tt class="docutils literal"><span class="pre">field_row</span></tt>
que vem com o Symfony).</p>
<p>Para personalizar qualquer parte de um formulário, você só precisa substituir o fragmento
apropriado. Saber exatamente qual bloco ou arquivo deve-se substituir é o tema da
próxima seção.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 2.1: </span>Foi introduzida uma sintaxe alternativa do Twig para <tt class="docutils literal"><span class="pre">form_theme</span></tt> no 2.1. Ela aceita
qualquer expressão Twig válida (a diferença mais notável está no uso de um array quando
utilizar vários temas).</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="c">{# src/Acme/TaskBundle/Resources/views/Default/new.html.twig #}</span>

<span class="cp">{%</span> <span class="k">form_theme</span> <span class="nv">form</span> <span class="k">with</span> <span class="s1">&#39;AcmeTaskBundle:Form:fields.html.twig&#39;</span> <span class="cp">%}</span>

<span class="cp">{%</span> <span class="k">form_theme</span> <span class="nv">form</span> <span class="k">with</span> <span class="o">[</span><span class="s1">&#39;AcmeTaskBundle:Form:fields.html.twig&#39;</span><span class="o">,</span> <span class="s1">&#39;AcmeTaskBundle:Form:fields2.html.twig&#39;</span><span class="o">]</span> <span class="cp">%}</span>
</pre></div>
</div>
</div>
<p>Para uma discussão mais extensiva, consulte <a class="reference internal" href="../cookbook/form/form_customization.html"><em>Como personalizar a Renderização de Formulários</em></a>.</p>
<div class="section" id="nomeando-os-fragmentos-do-formulario">
<span id="form-template-blocks"></span><span id="index-17"></span><h3>Nomeando os fragmentos do formulário<a class="headerlink" href="#nomeando-os-fragmentos-do-formulario" title="Permalink to this headline">¶</a></h3>
<p>No Symfony, cada parte de um formulário que é renderizada - elementos de formulário HTML, erros,
labels, etc - é definida em um tema base, que é uma coleção de blocos
no Twig e uma coleção de arquivos de template no PHP.</p>
<p>No Twig, cada bloco necessário é definido em um único arquivo de template (<a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Bridge/Twig/Resources/views/Form/form_div_layout.html.twig">form_div_layout.html.twig</a>)
que encontra-se no interior do <a class="reference external" href="https://github.com/symfony/symfony/tree/master/src/Symfony/Bridge/Twig">Twig Bridge</a>. Dentro desse arquivo, você pode ver todos os blocos
necessários para renderizar um formulário e todo o tipo de campo padrão.</p>
<p>No PHP, os fragmentos são arquivos de template individuais. Por padrão, eles estão localizados no
diretório <cite>Resources/views/Form</cite> do framework bundle (<a class="reference external" href="https://github.com/symfony/symfony/tree/master/src/Symfony/Bundle/FrameworkBundle/Resources/views/Form">veja no GitHub</a>).</p>
<p>Cada nome de fragmento segue o mesmo padrão básico e é dividido em duas partes,
separadas por um único caractere de sublinhado (<tt class="docutils literal"><span class="pre">_</span></tt>). Alguns exemplos são:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">field_row</span></tt> - usado pelo <tt class="docutils literal"><span class="pre">form_row</span></tt> para renderizar a maioria dos campos;</li>
<li><tt class="docutils literal"><span class="pre">textarea_widget</span></tt> - usado pelo <tt class="docutils literal"><span class="pre">form_widget</span></tt> para renderizar um campo do tipo
<tt class="docutils literal"><span class="pre">textarea</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">field_errors</span></tt> - usado pelo <tt class="docutils literal"><span class="pre">form_errors</span></tt> para renderizar os erros para um campo;</li>
</ul>
<p>Cada fragmento segue o mesmo padrão básico: <tt class="docutils literal"><span class="pre">type_part</span></tt>. A porção <tt class="docutils literal"><span class="pre">type</span></tt>
corresponde ao <em>tipo</em> do campo sendo renderizado (Ex. <tt class="docutils literal"><span class="pre">textarea</span></tt>, <tt class="docutils literal"><span class="pre">checkbox</span></tt>,
<tt class="docutils literal"><span class="pre">date</span></tt>, etc) enquanto a porção <tt class="docutils literal"><span class="pre">part</span></tt> corresponde a <em>o que</em> está sendo
renderizado (Ex., <tt class="docutils literal"><span class="pre">label</span></tt>, <tt class="docutils literal"><span class="pre">widget</span></tt>, <tt class="docutils literal"><span class="pre">errors</span></tt>, etc). Por padrão, existem
4 <em>partes</em> possíveis de um formulário que podem ser renderizadas:</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="26%" />
<col width="61%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">label</span></tt></td>
<td>(Ex. <tt class="docutils literal"><span class="pre">field_label</span></tt>)</td>
<td>renderiza label do campo</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">widget</span></tt></td>
<td>(Ex. <tt class="docutils literal"><span class="pre">field_widget</span></tt>)</td>
<td>renderiza a representação HTML do campo</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">errors</span></tt></td>
<td>(Ex. <tt class="docutils literal"><span class="pre">field_errors</span></tt>)</td>
<td>renderiza os errors do campo</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">row</span></tt></td>
<td>(Ex. <tt class="docutils literal"><span class="pre">field_row</span></tt>)</td>
<td>renderiza a linha inteira do campo (label, widget e erros)</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Na verdade, existem outras três <em>partes</em> - <tt class="docutils literal"><span class="pre">rows</span></tt>, <tt class="docutils literal"><span class="pre">rest</span></tt> e <tt class="docutils literal"><span class="pre">enctype</span></tt> -
mas você raramente ou nunca vai precisar se preocupar em sobrescrevê-las</p>
</div>
<p>Ao conhecer o tipo do campo (Ex. `` textarea``) e qual parte você deseja
personalizar (Ex. <tt class="docutils literal"><span class="pre">widget</span></tt>), você pode construir o nome do fragmento que precisa
ser sobrescrito (Ex. <tt class="docutils literal"><span class="pre">textarea_widget</span></tt>).</p>
</div>
<div class="section" id="heranca-dos-fragmentos-de-template">
<span id="index-18"></span><h3>Herança dos fragmentos de template<a class="headerlink" href="#heranca-dos-fragmentos-de-template" title="Permalink to this headline">¶</a></h3>
<p>Em alguns casos, o fragmento que você deseja personalizar parecerá estar faltando.
Por exemplo, não existe um fragmento <tt class="docutils literal"><span class="pre">textarea_errors</span></tt> nos temas padrão
fornecidos com o Symfony. Então, como são renderizados os erros de um campo textarea?</p>
<p>A resposta é: através do fragmento <tt class="docutils literal"><span class="pre">field_errors</span></tt>. Quando o Symfony renderiza os erros
para um tipo textarea, ele procura primeiro por um fragmento <tt class="docutils literal"><span class="pre">textarea_errors</span></tt> antes
de voltar para o fragmento <tt class="docutils literal"><span class="pre">field_errors</span></tt>. Cada tipo de campo tem um tipo
<em>pai</em> (o tipo pai do <tt class="docutils literal"><span class="pre">textarea</span></tt> é <tt class="docutils literal"><span class="pre">field</span></tt>), e o Symfony usa
o fragmento para o tipo pai se o fragmento base não existir.</p>
<p>Então, para substituir os erros para <em>apenas</em> os campos <tt class="docutils literal"><span class="pre">textarea</span></tt>, copie o
fragmento <tt class="docutils literal"><span class="pre">field_errors</span></tt>, renomeie para <tt class="docutils literal"><span class="pre">textarea_errors</span></tt> e personalize-o. Para
sobrescrever a renderização de erro padrão para <em>todos</em> os campos, copie e personalize
diretamente o fragmento <tt class="docutils literal"><span class="pre">field_errors</span></tt>.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">O tipo &#8220;pai&#8221; de cada tipo de campo está disponível na
<a class="reference internal" href="../reference/forms/types.html"><em>referência de tipos do formulário</em></a> para cada tipo de campo.</p>
</div>
</div>
<div class="section" id="tematizando-os-formularios-globalmente">
<span id="index-19"></span><h3>Tematizando os formulários globalmente<a class="headerlink" href="#tematizando-os-formularios-globalmente" title="Permalink to this headline">¶</a></h3>
<p>No exemplo acima, você usou o helper <tt class="docutils literal"><span class="pre">form_theme</span></tt> (no Twig) para &#8220;importar&#8221;
os fragmentos personalizados <em>somente</em> para este formulário. Você também pode dizer
ao Symfony para importar as personalizações do formulário para todo o seu projeto.</p>
<div class="section" id="twig">
<h4>Twig<a class="headerlink" href="#twig" title="Permalink to this headline">¶</a></h4>
<p>Para incluir automaticamente os blocos personalizados do template <tt class="docutils literal"><span class="pre">fields.html.twig</span></tt>
criado anteriormente em <em>todos</em> os templates, modifique o seu arquivo de configuração
da aplicação:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># app/config/config.yml</span>

<span class="l-Scalar-Plain">twig</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">form</span><span class="p-Indicator">:</span>
        <span class="l-Scalar-Plain">resources</span><span class="p-Indicator">:</span>
            <span class="p-Indicator">-</span> <span class="s">&#39;AcmeTaskBundle:Form:fields.html.twig&#39;</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre>&lt;!-- app/config/config.xml --&gt;

&lt;twig:config ...&gt;
        &lt;twig:form&gt;
            &lt;resource&gt;AcmeTaskBundle:Form:fields.html.twig&lt;/resource&gt;
        &lt;/twig:form&gt;
        &lt;!-- ... --&gt;
&lt;/twig:config&gt;
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="c1">// app/config/config.php</span>

<span class="nv">$container</span><span class="o">-&gt;</span><span class="na">loadFromExtension</span><span class="p">(</span><span class="s1">&#39;twig&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;form&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;resources&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span>
        <span class="s1">&#39;AcmeTaskBundle:Form:fields.html.twig&#39;</span><span class="p">,</span>
     <span class="p">))</span>
    <span class="c1">// ...</span>
<span class="p">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Quaisquer blocos dentro do template <tt class="docutils literal"><span class="pre">fields.html.twig</span></tt> agora são usados ​​globalmente
para definir a saída do formulário.</p>
<div class="sidebar">
<p class="first sidebar-title">Personalizando toda a saída do formulário em um único arquivo com o Twig</p>
<p>No Twig, você também pode personalizar um bloco de formulário diretamente dentro do template
onde a personalização é necessária:</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">extends</span> <span class="s1">&#39;::base.html.twig&#39;</span> <span class="cp">%}</span>

<span class="c">{# import &quot;_self&quot; as the form theme #}</span>
<span class="cp">{%</span> <span class="k">form_theme</span> <span class="nv">form</span> <span class="p">_</span><span class="nv">self</span> <span class="cp">%}</span>

<span class="c">{# make the form fragment customization #}</span>
<span class="cp">{%</span> <span class="k">block</span> <span class="nv">field_row</span> <span class="cp">%}</span>
    <span class="c">{# custom field row output #}</span>
<span class="cp">{%</span> <span class="k">endblock</span> <span class="nv">field_row</span> <span class="cp">%}</span>

<span class="cp">{%</span> <span class="k">block</span> <span class="nv">content</span> <span class="cp">%}</span>
    <span class="c">{# ... #}</span>

    <span class="cp">{{</span> <span class="nv">form_row</span><span class="o">(</span><span class="nv">form.task</span><span class="o">)</span> <span class="cp">}}</span>
<span class="cp">{%</span> <span class="k">endblock</span> <span class="cp">%}</span>
</pre></div>
</div>
<p class="last">A tag <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">form_theme</span> <span class="pre">form</span> <span class="pre">_self</span> <span class="pre">%}</span></tt> permite que blocos de formulário sejam personalizados
diretamente dentro do template que usará essas personalizações. Utilize
este método para fazer personalizações de saída do formulário rapidamente, que, somente
serão necessárias em um único template.</p>
</div>
</div>
<div class="section" id="php">
<h4>PHP<a class="headerlink" href="#php" title="Permalink to this headline">¶</a></h4>
<p>Para incluir automaticamente os templates personalizados do diretório <tt class="docutils literal"><span class="pre">Acme/TaskBundle/Resources/views/Form</span></tt>
criado anteriormente em <em>todos</em> os templates, modifique o seu arquivo de configuração da
aplicação:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># app/config/config.yml</span>

<span class="l-Scalar-Plain">framework</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">templating</span><span class="p-Indicator">:</span>
        <span class="l-Scalar-Plain">form</span><span class="p-Indicator">:</span>
            <span class="l-Scalar-Plain">resources</span><span class="p-Indicator">:</span>
                <span class="p-Indicator">-</span> <span class="s">&#39;AcmeTaskBundle:Form&#39;</span>
<span class="c1"># ...</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre>&lt;!-- app/config/config.xml --&gt;

&lt;framework:config ...&gt;
    &lt;framework:templating&gt;
        &lt;framework:form&gt;
            &lt;resource&gt;AcmeTaskBundle:Form&lt;/resource&gt;
        &lt;/framework:form&gt;
    &lt;/framework:templating&gt;
    &lt;!-- ... --&gt;
&lt;/framework:config&gt;
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="c1">// app/config/config.php</span>

<span class="nv">$container</span><span class="o">-&gt;</span><span class="na">loadFromExtension</span><span class="p">(</span><span class="s1">&#39;framework&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;templating&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;form&#39;</span> <span class="o">=&gt;</span>
        <span class="k">array</span><span class="p">(</span><span class="s1">&#39;resources&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;AcmeTaskBundle:Form&#39;</span><span class="p">,</span>
     <span class="p">)))</span>
    <span class="c1">// ...</span>
<span class="p">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Qualquer fragmento dentro do diretório <tt class="docutils literal"><span class="pre">Acme/TaskBundle/Resources/views/Form</span></tt>
agora será usado ​​globalmente para definir a saída do formulário.</p>
</div>
</div>
</div>
<div class="section" id="protecao-csrf">
<span id="forms-csrf"></span><span id="index-20"></span><h2>Proteção CSRF<a class="headerlink" href="#protecao-csrf" title="Permalink to this headline">¶</a></h2>
<p>CSRF - ou <a class="reference external" href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">Cross-site request forgery</a> - é um método pelo qual um usuário mal-intencionado
tenta fazer com que os seus usuários legítimos, sem saber, enviem dados que
eles não pretendem enviar. Felizmente, os ataques CSRF podem ser prevenidos
usando um token CSRF dentro do seu formulário.</p>
<p>A boa notícia é que o Symfony, por padrão, incorpora e valida os tokens CSRF
automaticamente para você. Isso significa que você pode aproveitar a proteção CSRF
sem precisar fazer nada. Na verdade, todo formulário neste capítulo
aproveitou a proteção CSRF!</p>
<p>A proteção CSRF funciona adicionando um campo oculto ao seu formulário - chamado <tt class="docutils literal"><span class="pre">_token</span></tt>
por padrão - que contém um valor que só você e seu usuário sabem. Isto
garante que o usuário - e não alguma outra entidade - está enviando os dados.
O Symfony automaticamente valida a presença e exatidão deste token.</p>
<p>O campo <tt class="docutils literal"><span class="pre">_token</span></tt> é um campo oculto e será automaticamente renderizado
se você incluir a função <tt class="docutils literal"><span class="pre">form_rest()</span></tt> em seu template, que garante
a saída de todos os campos não-renderizados.</p>
<p>O token CSRF pode ser personalizado formulário por formulário. Por exemplo:</p>
<div class="highlight-python"><div class="highlight"><pre>use Symfony\Component\OptionsResolver\OptionsResolverInterface;

class TaskType extends AbstractType
{
    // ...

    public function setDefaultOptions(OptionsResolverInterface $resolver)
    {
        $resolver-&gt;setDefaults(array(
            &#39;data_class&#39;      =&gt; &#39;Acme\TaskBundle\Entity\Task&#39;,
            &#39;csrf_protection&#39; =&gt; true,
            &#39;csrf_field_name&#39; =&gt; &#39;_token&#39;,
            // a unique key to help generate the secret token
            &#39;intention&#39;       =&gt; &#39;task_item&#39;,
        ));
    }

    // ...
}
</pre></div>
</div>
<p>Para desativar a proteção CSRF, defina a opção <tt class="docutils literal"><span class="pre">csrf_protection</span></tt> para false.
As personalizações também podem ser feitas globalmente em seu projeto. Para mais informações
veja a seção <em class="xref std std-ref">referência de configuração do formulário</em>
.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A opção <tt class="docutils literal"><span class="pre">intention</span></tt> é opcional, mas aumenta muito a segurança do
token gerado, tornando-o diferente para cada formulário.</p>
</div>
</div>
<div class="section" id="utilizando-um-formulario-sem-uma-classe">
<h2>Utilizando um formulário sem uma classe<a class="headerlink" href="#utilizando-um-formulario-sem-uma-classe" title="Permalink to this headline">¶</a></h2>
<p>Na maioria dos casos, um formulário é vinculado a um objeto, e os campos do formulário obtêm
e armazenam seus dados nas propriedades desse objeto. Isto foi exatamente o que
você viu até agora neste capítulo com a classe <cite>Task</cite>.</p>
<p>Mas, às vezes, você pode desejar apenas utilizar um formulário sem uma classe, e receber
um array dos dados submetidos. Isso é realmente muito fácil:</p>
<div class="highlight-python"><div class="highlight"><pre>// Certifique-se que você importou o namespace Request acima da classe
use Symfony\Component\HttpFoundation\Request
// ...

public function contactAction(Request $request)
{
    $defaultData = array(&#39;message&#39; =&gt; &#39;Type your message here&#39;);
    $form = $this-&gt;createFormBuilder($defaultData)
        -&gt;add(&#39;name&#39;, &#39;text&#39;)
        -&gt;add(&#39;email&#39;, &#39;email&#39;)
        -&gt;add(&#39;message&#39;, &#39;textarea&#39;)
        -&gt;getForm();

        if ($request-&gt;isMethod(&#39;POST&#39;)) {
            $form-&gt;bind($request);

            // data is an array with &quot;name&quot;, &quot;email&quot;, and &quot;message&quot; keys
            $data = $form-&gt;getData();
        }

    // ... render the form
}
</pre></div>
</div>
<p>Por padrão, um formulário assume que você deseja trabalhar com arrays de
dados, em vez de um objeto. Há exatamente duas maneiras em que você pode mudar
esse comportamento e amarrar o formulário à um objeto:</p>
<ol class="arabic simple">
<li>Passar um objeto ao criar o formulário (como o primeiro argumento para <tt class="docutils literal"><span class="pre">createFormBuilder</span></tt>
ou o segundo argumento para <tt class="docutils literal"><span class="pre">createForm</span></tt>);</li>
<li>Declarar a opção <tt class="docutils literal"><span class="pre">data_class</span></tt> no seu formulário.</li>
</ol>
<p>Se você <em>não</em> fizer qualquer uma destas, então o formulário irá retornar os dados como
um array. Neste exemplo, uma vez que <tt class="docutils literal"><span class="pre">$defaultData</span></tt> não é um objeto (e
não foi definida a opção <tt class="docutils literal"><span class="pre">data_class</span></tt>), o <tt class="docutils literal"><span class="pre">$form-&gt;getData()</span></tt> retorna
um array.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>Você também pode acessar os valores POST (neste caso, &#8220;name&#8221;) diretamente através
do objeto do pedido (<tt class="docutils literal"><span class="pre">request</span></tt>), desta forma:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;request&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">request</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p class="last">Esteja ciente, no entanto, que, na maioria dos casos, usar o método getData() é
uma melhor escolha, já que retorna os dados (geralmente um objeto), após
ele ser transformado pelo framework de formulário.</p>
</div>
<div class="section" id="adicionando-a-validacao">
<h3>Adicionando a Validação<a class="headerlink" href="#adicionando-a-validacao" title="Permalink to this headline">¶</a></h3>
<p>A peça que falta é a validação. Normalmente, quando você chama <tt class="docutils literal"><span class="pre">$form-&gt;isValid()</span></tt>,
o objeto é validado através da leitura das <em>constraints</em> que você aplicou à
classe. Mas, sem uma classe, como você pode adicionar <em>constraints</em> para os dados do seu
formulário?</p>
<p>A resposta é configurar as <em>constraints</em> você mesmo, e passá-las para o seu
formulário. A abordagem global é explicada um pouco mais no <a class="reference internal" href="validation.html#book-validation-raw-values"><em>validation chapter</em></a>,
mas aqui está um pequeno exemplo:</p>
<div class="highlight-python"><div class="highlight"><pre>// import the namespaces above your controller class
use Symfony\Component\Validator\Constraints\Email;
use Symfony\Component\Validator\Constraints\MinLength;
use Symfony\Component\Validator\Constraints\Collection;

$collectionConstraint = new Collection(array(
    &#39;name&#39; =&gt; new MinLength(5),
    &#39;email&#39; =&gt; new Email(array(&#39;message&#39; =&gt; &#39;Invalid email address&#39;)),
));

// create a form, no default values, pass in the constraint option
$form = $this-&gt;createFormBuilder(null, array(
    &#39;validation_constraint&#39; =&gt; $collectionConstraint,
))-&gt;add(&#39;email&#39;, &#39;email&#39;)
    // ...
;
</pre></div>
</div>
<p>Agora, quando você chamar <cite>$form-&gt;bind($request)</cite>, a configuração de <em>constraints</em> aqui será executada
em relação aos dados do seu formulário. Se você estiver usando uma classe de formulário, sobrescreva
o método <tt class="docutils literal"><span class="pre">setDefaultOptions</span></tt> para especificar a opção:</p>
<div class="highlight-python"><div class="highlight"><pre>namespace Acme\TaskBundle\Form\Type;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\FormBuilder;
use Symfony\Component\OptionsResolver\OptionsResolverInterface;
use Symfony\Component\Validator\Constraints\Email;
use Symfony\Component\Validator\Constraints\MinLength;
use Symfony\Component\Validator\Constraints\Collection;

class ContactType extends AbstractType
{
    // ...

    public function setDefaultOptions(OptionsResolverInterface $resolver)
    {
        $collectionConstraint = new Collection(array(
            &#39;name&#39; =&gt; new MinLength(5),
            &#39;email&#39; =&gt; new Email(array(&#39;message&#39; =&gt; &#39;Invalid email address&#39;)),
        ));

        $resolver-&gt;setDefaults(array(
            &#39;validation_constraint&#39; =&gt; $collectionConstraint
        ));
    }
}
</pre></div>
</div>
<p>Agora, você tem a flexibilidade de criar formulários - com validação - que retorna
um array de dados, em vez de um objeto. Na maioria dos casos, é melhor - e
certamente mais robusto - ligar (bind) o seu formulário à um objeto. Mas, para formulários simples,
esta é uma excelente abordagem.</p>
</div>
</div>
<div class="section" id="consideracoes-finais">
<h2>Considerações finais<a class="headerlink" href="#consideracoes-finais" title="Permalink to this headline">¶</a></h2>
<p>Você já conhece todos os blocos de construção necessários para construir formulários complexos e
funcionais para a sua aplicação. Ao construir formulários, tenha em mente que
a primeira meta de um formulário é traduzir os dados de um objeto (<tt class="docutils literal"><span class="pre">Task</span></tt>) para um
formulário HTML, para que o usuário possa modificar os dados. O segundo objetivo de um formulário é
pegar os dados enviados pelo usuário e reaplicá-los ao objeto.</p>
<p>Ainda há muito mais para aprender sobre o mundo poderoso das formulários, tais como
como lidar com <a class="reference internal" href="../cookbook/doctrine/file_uploads.html"><em>uploads de arquivos com o Doctrine</em></a>
ou como criar um formulário onde um número dinâmico de sub-formulários podem ser adicionados
(por exemplo, uma lista de tarefas onde você pode continuar a adicionar
mais campos antes de enviar via Javascript). Veja estes tópicos no
cookbook. Além disso, certifique-se de apoiar-se na
<a class="reference internal" href="../reference/forms/types.html"><em>documentação de referência de tipos de campo</em></a>, que
inclui exemplos de como usar cada tipo de campo e suas opções.</p>
</div>
<div class="section" id="aprenda-mais-no-cookbook">
<h2>Aprenda mais no Cookbook<a class="headerlink" href="#aprenda-mais-no-cookbook" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="../cookbook/doctrine/file_uploads.html"><em>Como Manipular o Upload de Arquivos com o Doctrine</em></a></li>
<li><tt class="xref doc docutils literal"><span class="pre">File</span> <span class="pre">Field</span> <span class="pre">Reference</span></tt></li>
<li><a class="reference internal" href="../cookbook/form/create_custom_field_type.html"><em>Creating Custom Field Types</em></a></li>
<li><a class="reference internal" href="../cookbook/form/form_customization.html"><em>Como personalizar a Renderização de Formulários</em></a></li>
<li><tt class="xref doc docutils literal"><span class="pre">/cookbook/form/dynamic_form_generation</span></tt></li>
<li><a class="reference internal" href="../cookbook/form/data_transformers.html"><em>Como usar os Transformadores de Dados</em></a></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Formulários</a><ul>
<li><a class="reference internal" href="#criando-um-formulario-simples">Criando um formulário simples</a><ul>
<li><a class="reference internal" href="#construindo-o-formulario">Construindo o Formulário</a></li>
<li><a class="reference internal" href="#renderizando-o-formulario">Renderizando o Formulário</a></li>
<li><a class="reference internal" href="#manipulando-o-envio-de-formularios">Manipulando o envio de formulários</a></li>
</ul>
</li>
<li><a class="reference internal" href="#validacao-do-formulario">Validação do formulário</a><ul>
<li><a class="reference internal" href="#grupos-de-validacao">Grupos de Validação</a></li>
<li><a class="reference internal" href="#grupos-com-base-nos-dados-submetidos">Grupos com base nos dados submetidos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tipos-de-campos-integrados-built-in">Tipos de campos integrados (Built-in)</a><ul>
<li><a class="reference internal" href="#opcoes-dos-tipos-de-campos">Opções dos tipos de campos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#adivinhando-o-tipo-do-campo">Adivinhando o tipo do campo</a><ul>
<li><a class="reference internal" href="#adivinhando-as-opcoes-dos-tipos-de-campos">Adivinhando as opções dos tipos de campos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#renderizando-um-formulario-em-um-template">Renderizando um formulário em um Template</a><ul>
<li><a class="reference internal" href="#renderizando-cada-campo-manualmente">Renderizando cada campo manualmente</a></li>
<li><a class="reference internal" href="#referencia-de-funcoes-dos-templates-twig">Referência de funções dos templates Twig</a></li>
</ul>
</li>
<li><a class="reference internal" href="#criando-classes-de-formulario">Criando classes de formulário</a></li>
<li><a class="reference internal" href="#formularios-e-o-doctrine">Formulários e o Doctrine</a></li>
<li><a class="reference internal" href="#formularios-embutidos">Formulários embutidos</a><ul>
<li><a class="reference internal" href="#embutindo-um-unico-objeto">Embutindo um único objeto</a></li>
<li><a class="reference internal" href="#embutindo-uma-colecao-de-formularios">Embutindo uma coleção de formulários</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tematizando-os-formularios">Tematizando os formulários</a><ul>
<li><a class="reference internal" href="#nomeando-os-fragmentos-do-formulario">Nomeando os fragmentos do formulário</a></li>
<li><a class="reference internal" href="#heranca-dos-fragmentos-de-template">Herança dos fragmentos de template</a></li>
<li><a class="reference internal" href="#tematizando-os-formularios-globalmente">Tematizando os formulários globalmente</a><ul>
<li><a class="reference internal" href="#twig">Twig</a></li>
<li><a class="reference internal" href="#php">PHP</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#protecao-csrf">Proteção CSRF</a></li>
<li><a class="reference internal" href="#utilizando-um-formulario-sem-uma-classe">Utilizando um formulário sem uma classe</a><ul>
<li><a class="reference internal" href="#adicionando-a-validacao">Adicionando a Validação</a></li>
</ul>
</li>
<li><a class="reference internal" href="#consideracoes-finais">Considerações finais</a></li>
<li><a class="reference internal" href="#aprenda-mais-no-cookbook">Aprenda mais no Cookbook</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="validation.html"
                        title="previous chapter">Validação</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="security.html"
                        title="next chapter">Segurança</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/book/forms.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="security.html" title="Segurança"
             >next</a> |</li>
        <li class="right" >
          <a href="validation.html" title="Validação"
             >previous</a> |</li>
        <li><a href="../index.html">Symfony2.4Docs 2.4 documentation</a> &raquo;</li>
          <li><a href="index.html" >Livro</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Symfony Team + Symfony pt_BR Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>